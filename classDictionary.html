<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>NEST: Dictionary Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NEST
   &#160;<span id="projectnumber">2.6.0,not_revisioned_source_dir@0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classDictionary-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Dictionary Class Reference<div class="ingroups"><a class="el" href="group__TokenHandling.html">Handling classes Token and Dictionary.</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class that associates names and tokens.  
 <a href="classDictionary.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dict_8h_source.html">dict.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Dictionary:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classDictionary.png" usemap="#Dictionary_map" alt=""/>
  <map id="Dictionary_map" name="Dictionary_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary_1_1DictItemLexicalOrder.html">DictItemLexicalOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for lexicographical sorting of dictionary entries.  <a href="classDictionary_1_1DictItemLexicalOrder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aecc5dd681aa96dd75d10d690b14d5ac9"><td class="memItemLeft" align="right" valign="top">typedef TokenMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#aecc5dd681aa96dd75d10d690b14d5ac9">const_iterator</a></td></tr>
<tr class="memdesc:aecc5dd681aa96dd75d10d690b14d5ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant iterator for dictionary.  <a href="#aecc5dd681aa96dd75d10d690b14d5ac9">More...</a><br /></td></tr>
<tr class="separator:aecc5dd681aa96dd75d10d690b14d5ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aee8d612bc9d323c38faba045ba384b8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#aee8d612bc9d323c38faba045ba384b8b">Dictionary</a> ()</td></tr>
<tr class="separator:aee8d612bc9d323c38faba045ba384b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2488ccf03c1226ec191b2dac3fd252a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a2488ccf03c1226ec191b2dac3fd252a4">Dictionary</a> (const <a class="el" href="classDictionary.html">Dictionary</a> &amp;d)</td></tr>
<tr class="separator:a2488ccf03c1226ec191b2dac3fd252a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36f24073d9c9001768517aa2322cb82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#aa36f24073d9c9001768517aa2322cb82">~Dictionary</a> ()</td></tr>
<tr class="separator:aa36f24073d9c9001768517aa2322cb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d54b74d14335da04ad9d64e49536d9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a2d54b74d14335da04ad9d64e49536d9a">clear</a> ()</td></tr>
<tr class="separator:a2d54b74d14335da04ad9d64e49536d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa0e0b84d483fff3a4930fabb303d20"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classToken.html">Token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#abaa0e0b84d483fff3a4930fabb303d20">lookup</a> (const <a class="el" href="className.html">Name</a> &amp;n) const </td></tr>
<tr class="memdesc:abaa0e0b84d483fff3a4930fabb303d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return <a class="el" href="classToken.html" title="A type-independent container for C++-types. ">Token</a> with given name in dictionary.  <a href="#abaa0e0b84d483fff3a4930fabb303d20">More...</a><br /></td></tr>
<tr class="separator:abaa0e0b84d483fff3a4930fabb303d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088dd49df05e0a626c45cca14cb7e54a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classToken.html">Token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a088dd49df05e0a626c45cca14cb7e54a">lookup2</a> (const <a class="el" href="className.html">Name</a> &amp;n) const </td></tr>
<tr class="memdesc:a088dd49df05e0a626c45cca14cb7e54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">lookup a name in the dictionary.  <a href="#a088dd49df05e0a626c45cca14cb7e54a">More...</a><br /></td></tr>
<tr class="separator:a088dd49df05e0a626c45cca14cb7e54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6272d6b81f9df2adc740118634c68fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#ac6272d6b81f9df2adc740118634c68fb">known</a> (const <a class="el" href="className.html">Name</a> &amp;) const </td></tr>
<tr class="separator:ac6272d6b81f9df2adc740118634c68fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4734127601ba07fb27540a68e5bab5c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a4734127601ba07fb27540a68e5bab5c6">known_but_not_accessed</a> (const <a class="el" href="className.html">Name</a> &amp;) const </td></tr>
<tr class="memdesc:a4734127601ba07fb27540a68e5bab5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if name is known but token has not been accessed.  <a href="#a4734127601ba07fb27540a68e5bab5c6">More...</a><br /></td></tr>
<tr class="separator:a4734127601ba07fb27540a68e5bab5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94179a80d5b496321d68976e11dea85b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classToken.html">Token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a94179a80d5b496321d68976e11dea85b">insert</a> (const <a class="el" href="className.html">Name</a> &amp;n, const <a class="el" href="classToken.html">Token</a> &amp;t)</td></tr>
<tr class="separator:a94179a80d5b496321d68976e11dea85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce327c0a94abb3a166d805e74b8af57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classToken.html">Token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a9ce327c0a94abb3a166d805e74b8af57">insert_move</a> (const <a class="el" href="className.html">Name</a> &amp;, <a class="el" href="classToken.html">Token</a> &amp;)</td></tr>
<tr class="separator:a9ce327c0a94abb3a166d805e74b8af57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e425e8074008a20138010e513023b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#ac2e425e8074008a20138010e513023b7">remove</a> (const <a class="el" href="className.html">Name</a> &amp;n)</td></tr>
<tr class="memdesc:ac2e425e8074008a20138010e513023b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove entry from dictionary.  <a href="#ac2e425e8074008a20138010e513023b7">More...</a><br /></td></tr>
<tr class="separator:ac2e425e8074008a20138010e513023b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6b5c92768951c6d6b4329466b2bc1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classToken.html">Token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a7a6b5c92768951c6d6b4329466b2bc1e">operator[]</a> (const <a class="el" href="className.html">Name</a> &amp;) const </td></tr>
<tr class="separator:a7a6b5c92768951c6d6b4329466b2bc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c46b8638f07bf47a2d3a6933acf197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classToken.html">Token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a95c46b8638f07bf47a2d3a6933acf197">operator[]</a> (const <a class="el" href="className.html">Name</a> &amp;)</td></tr>
<tr class="separator:a95c46b8638f07bf47a2d3a6933acf197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa92cd3cc17be1f7740a4c55ca4f98d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classToken.html">Token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#aeaa92cd3cc17be1f7740a4c55ca4f98d">operator[]</a> (const char *) const </td></tr>
<tr class="separator:aeaa92cd3cc17be1f7740a4c55ca4f98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d1e3406daa9907edc2fbdd8dc01eb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classToken.html">Token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a27d1e3406daa9907edc2fbdd8dc01eb5">operator[]</a> (const char *)</td></tr>
<tr class="separator:a27d1e3406daa9907edc2fbdd8dc01eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309d27a7ae34065672ff4a53da6e1834"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a309d27a7ae34065672ff4a53da6e1834">empty</a> (void) const </td></tr>
<tr class="separator:a309d27a7ae34065672ff4a53da6e1834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659e34836e7382254d5b480e1f5cddf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a659e34836e7382254d5b480e1f5cddf5">info</a> (std::ostream &amp;) const </td></tr>
<tr class="separator:a659e34836e7382254d5b480e1f5cddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69652ade345979404aa4c06fd9e0d07a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a69652ade345979404aa4c06fd9e0d07a">operator==</a> (const <a class="el" href="classDictionary.html">Dictionary</a> &amp;d) const </td></tr>
<tr class="separator:a69652ade345979404aa4c06fd9e0d07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c26795421861bc5ab7e14cab352a97d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a3c26795421861bc5ab7e14cab352a97d">add_dict</a> (const std::string &amp;, <a class="el" href="classSLIInterpreter.html">SLIInterpreter</a> &amp;)</td></tr>
<tr class="memdesc:a3c26795421861bc5ab7e14cab352a97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the contents of this dictionary to another.  <a href="#a3c26795421861bc5ab7e14cab352a97d">More...</a><br /></td></tr>
<tr class="separator:a3c26795421861bc5ab7e14cab352a97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906120ec1c4f9ecc2fe449c39647862e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a906120ec1c4f9ecc2fe449c39647862e">remove_dict</a> (const std::string &amp;, <a class="el" href="classSLIInterpreter.html">SLIInterpreter</a> &amp;)</td></tr>
<tr class="memdesc:a906120ec1c4f9ecc2fe449c39647862e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove entries found in another dictionary from this.  <a href="#a906120ec1c4f9ecc2fe449c39647862e">More...</a><br /></td></tr>
<tr class="separator:a906120ec1c4f9ecc2fe449c39647862e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7c9604b0bdb71c173e53f0bcccfe30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a0e7c9604b0bdb71c173e53f0bcccfe30">clear_access_flags</a> ()</td></tr>
<tr class="memdesc:a0e7c9604b0bdb71c173e53f0bcccfe30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear access flags on all dictionary elements.  <a href="#a0e7c9604b0bdb71c173e53f0bcccfe30">More...</a><br /></td></tr>
<tr class="separator:a0e7c9604b0bdb71c173e53f0bcccfe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8650ae2f1460128136140c7442908bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#ad8650ae2f1460128136140c7442908bf">all_accessed</a> (std::string &amp;missed) const </td></tr>
<tr class="memdesc:ad8650ae2f1460128136140c7442908bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether all elements have been accessed.  <a href="#ad8650ae2f1460128136140c7442908bf">More...</a><br /></td></tr>
<tr class="separator:ad8650ae2f1460128136140c7442908bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc7f68007183b7882723c160347c9c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a2fc7f68007183b7882723c160347c9c0">initialize_property_array</a> (<a class="el" href="className.html">Name</a> propname)</td></tr>
<tr class="memdesc:a2fc7f68007183b7882723c160347c9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">First element in dictionary.  <a href="#a2fc7f68007183b7882723c160347c9c0">More...</a><br /></td></tr>
<tr class="separator:a2fc7f68007183b7882723c160347c9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035abf800f0d6db67a73b59c411e6ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a035abf800f0d6db67a73b59c411e6ace">add_dictstack_reference</a> ()</td></tr>
<tr class="memdesc:a035abf800f0d6db67a73b59c411e6ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called when a dictionary is pushed to the dictionary stack.  <a href="#a035abf800f0d6db67a73b59c411e6ace">More...</a><br /></td></tr>
<tr class="separator:a035abf800f0d6db67a73b59c411e6ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab002288fb70b83c59be633ed57627775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#ab002288fb70b83c59be633ed57627775">remove_dictstack_reference</a> ()</td></tr>
<tr class="memdesc:ab002288fb70b83c59be633ed57627775"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called when the dictionary is popped from the dictionary stack.  <a href="#ab002288fb70b83c59be633ed57627775">More...</a><br /></td></tr>
<tr class="separator:ab002288fb70b83c59be633ed57627775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab608677790e05f263d8d4ffb8c75e085"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#ab608677790e05f263d8d4ffb8c75e085">is_on_dictstack</a> () const </td></tr>
<tr class="memdesc:ab608677790e05f263d8d4ffb8c75e085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the dictionary has references on the dictionary stack.  <a href="#ab608677790e05f263d8d4ffb8c75e085">More...</a><br /></td></tr>
<tr class="separator:ab608677790e05f263d8d4ffb8c75e085"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a81409a822ef62f0296ed068879d7c18a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a81409a822ef62f0296ed068879d7c18a">all_accessed_</a> (std::string &amp;, std::string prefix=std::string()) const </td></tr>
<tr class="separator:a81409a822ef62f0296ed068879d7c18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aeae2c7a4f5ff9fae7abca41b1ea0042c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#aeae2c7a4f5ff9fae7abca41b1ea0042c">refs_on_dictstack_</a></td></tr>
<tr class="memdesc:aeae2c7a4f5ff9fae7abca41b1ea0042c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker function checking whether all elements have been accessed.  <a href="#aeae2c7a4f5ff9fae7abca41b1ea0042c">More...</a><br /></td></tr>
<tr class="separator:aeae2c7a4f5ff9fae7abca41b1ea0042c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aae99e575d88591825abd532f39ce92c5"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classToken.html">Token</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#aae99e575d88591825abd532f39ce92c5">VoidToken</a></td></tr>
<tr class="separator:aae99e575d88591825abd532f39ce92c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a59fdec7c54658e2fbbec8234d30898d7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDictionary.html#a59fdec7c54658e2fbbec8234d30898d7">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classDictionary.html">Dictionary</a> &amp;)</td></tr>
<tr class="separator:a59fdec7c54658e2fbbec8234d30898d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that associates names and tokens. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aecc5dd681aa96dd75d10d690b14d5ac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TokenMap::const_iterator <a class="el" href="classDictionary.html#aecc5dd681aa96dd75d10d690b14d5ac9">Dictionary::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant iterator for dictionary. </p>
<p><a class="el" href="classDictionary.html" title="A class that associates names and tokens. ">Dictionary</a> inherits privately from std::map to hide implementation details. To allow for inspection of all elements in a dictionary, we export the constant iterator type and begin() and end() methods. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aee8d612bc9d323c38faba045ba384b8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dictionary::Dictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2488ccf03c1226ec191b2dac3fd252a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dictionary::Dictionary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDictionary.html">Dictionary</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa36f24073d9c9001768517aa2322cb82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dictionary::~Dictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3c26795421861bc5ab7e14cab352a97d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dictionary::add_dict </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSLIInterpreter.html">SLIInterpreter</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the contents of this dictionary to another. </p>
<p>The target dictionary is given by names and must be retrieved via the interpreter. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000027">Todo:</a></b></dt><dd>Allow for free formatting of target dictionary entries via functor, and add traits to allow duplicates. <dl class="section see"><dt>See also</dt><dd><a class="el" href="classDictionary.html#a906120ec1c4f9ecc2fe449c39647862e" title="Remove entries found in another dictionary from this. ">remove_dict</a> </dd></dl>
</dd></dl>

<p>References <a class="el" href="classSLIInterpreter.html#afc60171047178064e02ff2814c99c472">SLIInterpreter::baselookup()</a>, and <a class="el" href="namespacenest_1_1names.html#ab8c67898fb04b2e13acb81c4d2b5bcdb">nest::names::d</a>.</p>

</div>
</div>
<a class="anchor" id="a035abf800f0d6db67a73b59c411e6ace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dictionary::add_dictstack_reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is called when a dictionary is pushed to the dictionary stack. </p>
<p>The dictioray stack must keep track about which dictioraries are on the dictionary stack. If a dictionary is modified and it is on the dictionary stack, the cache of the dictionary stack must be adjusted. This is e.g. the case for the systemdict or the errordict. </p>

<p>References <a class="el" href="classDictionary.html#aeae2c7a4f5ff9fae7abca41b1ea0042c">refs_on_dictstack_</a>.</p>

</div>
</div>
<a class="anchor" id="ad8650ae2f1460128136140c7442908bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dictionary::all_accessed </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>missed</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether all elements have been accessed. </p>
<p>Checks nested dictionaries recursively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::string&amp;</td><td>contains string with names of non-accessed entries </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all dictionary elements have been accessed </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this is just a wrapper, <a class="el" href="classDictionary.html#a81409a822ef62f0296ed068879d7c18a">all_accessed_()</a> does the work, hides recursion </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDictionary.html#a0e7c9604b0bdb71c173e53f0bcccfe30" title="Clear access flags on all dictionary elements. ">clear_access_flags()</a>, <a class="el" href="classDictionary.html#a81409a822ef62f0296ed068879d7c18a">all_accessed_()</a> </dd></dl>

<p>References <a class="el" href="classDictionary.html#a81409a822ef62f0296ed068879d7c18a">all_accessed_()</a>.</p>

<p>Referenced by <a class="el" href="namespacenest.html#a4645e8e2f7cba6d40a4b523c09cac226">nest::register_preconf_model()</a>.</p>

</div>
</div>
<a class="anchor" id="a81409a822ef62f0296ed068879d7c18a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dictionary::all_accessed_ </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>missed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classDictionary.html#ad8650ae2f1460128136140c7442908bf">all_accessed()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d54b74d14335da04ad9d64e49536d9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dictionary::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="namespacenest_1_1names.html#ac3540cafbc40e90b33f9dae9ee5a70f3">nest::names::clear</a>, <a class="el" href="classDictionary.html#a2d54b74d14335da04ad9d64e49536d9a">clear()</a>, <a class="el" href="namespacenest_1_1names.html#ab8c67898fb04b2e13acb81c4d2b5bcdb">nest::names::d</a>, <a class="el" href="namespacenest_1_1names.html#a2e8add5c0fc8124a8c7ec253468881fa">nest::names::dt</a>, <a class="el" href="classlockPTR.html#a0986f22390dbe822caf8107b1bacd03c">lockPTR&lt; D &gt;::get()</a>, and <a class="el" href="classlockPTR.html#a05c39698cc2d446d6f96e9669ecfb28f">lockPTR&lt; D &gt;::unlock()</a>.</p>

<p>Referenced by <a class="el" href="classDictionary.html#a2d54b74d14335da04ad9d64e49536d9a">clear()</a>, and <a class="el" href="classnest_1_1Network.html#a4c6c1b2a7bc543f64715f781088200a1">nest::Network::clear_models_()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e7c9604b0bdb71c173e53f0bcccfe30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dictionary::clear_access_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear access flags on all dictionary elements. </p>
<p>Flags for nested dictionaries are cleared recursively. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classDictionary.html#ad8650ae2f1460128136140c7442908bf" title="Check whether all elements have been accessed. ">all_accessed()</a> </dd></dl>

<p>Referenced by <a class="el" href="namespacenest.html#a4645e8e2f7cba6d40a4b523c09cac226">nest::register_preconf_model()</a>.</p>

</div>
</div>
<a class="anchor" id="a309d27a7ae34065672ff4a53da6e1834"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dictionary::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a659e34836e7382254d5b480e1f5cddf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dictionary::info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2fc7f68007183b7882723c160347c9c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dictionary::initialize_property_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="className.html">Name</a>&#160;</td>
          <td class="paramname"><em>propname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>First element in dictionary. </p>
<p><a class="el" href="classDictionary.html" title="A class that associates names and tokens. ">Dictionary</a> inherits privately from std::map to hide implementation details. To allow for inspection of all elements in a dictionary, we export the constant iterator type and begin() and end() methods. One-past-last element in dictionary. <a class="el" href="classDictionary.html" title="A class that associates names and tokens. ">Dictionary</a> inherits privately from std::map to hide implementation details. To allow for inspection of all elements in a dictionary, we export the constant iterator type and begin() and end() methods. </p>

</div>
</div>
<a class="anchor" id="a94179a80d5b496321d68976e11dea85b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken.html">Token</a> &amp; Dictionary::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="className.html">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classToken.html">Token</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a23a5d25f4416daaf084f2d5f3499c33e">nest::Network::copy_model()</a>, <a class="el" href="classSLIInterpreter.html#a1d4268e9a4b8064b77e12fba24d15620">SLIInterpreter::execute_()</a>, <a class="el" href="classSLIInterpreter.html#a2e551e6c11e2e8158d163e2b5996c33d">SLIInterpreter::execute_debug_()</a>, <a class="el" href="classRegexpModule.html#af5ed0a3faa939c0bf220abec31e6b102">RegexpModule::init()</a>, <a class="el" href="classProcesses.html#a13503e25b43373330c38421d96f910ad">Processes::init()</a>, <a class="el" href="classnest_1_1Network.html#af7c91cf9bdca31c25878d322426552bf">nest::Network::init_()</a>, <a class="el" href="group__SLIError.html#gac13fa0ddc13dfcd5b3c0c7116e10cdac">SLIInterpreter::raiseagain()</a>, <a class="el" href="classSLIInterpreter.html#a64a24809b92a555db7b56629b9b7267e">SLIInterpreter::raiseerror()</a>, <a class="el" href="group__SLIError.html#gab1f76ff8c7308acedfa1017ffe2c7de4">SLIInterpreter::raisesignal()</a>, <a class="el" href="classnest_1_1Network.html#a41f45c4e00263c4dcfac919efa2fab27">nest::Network::register_conn_builder()</a>, <a class="el" href="classnest_1_1Network.html#a0270f32871ef27b62dad37da238361ac">nest::Network::register_model()</a>, and <a class="el" href="classSLIInterpreter.html#a1deb2a48e952d58ce8e96422390f8b76">SLIInterpreter::SLIInterpreter()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ce327c0a94abb3a166d805e74b8af57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken.html">Token</a> &amp; Dictionary::insert_move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="className.html">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classToken.html#a2f61f1702fa6214de27ccff368df11f5">Token::move()</a>.</p>

<p>Referenced by <a class="el" href="classlibrandom_1_1GslRandomGen.html#a310ca668d42388c8a49256e7d65d12f2">librandom::GslRandomGen::add_gsl_rngs()</a>, <a class="el" href="group__SLIError.html#ga098156501ff35f206a32d389bf262e05">SLIInterpreter::raiseerror()</a>, and <a class="el" href="classRandomNumbers.html#a05c744034abc56b2f599aa658c60ff66">RandomNumbers::register_rdv_()</a>.</p>

</div>
</div>
<a class="anchor" id="ab608677790e05f263d8d4ffb8c75e085"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dictionary::is_on_dictstack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the dictionary has references on the dictionary stack. </p>

<p>References <a class="el" href="classDictionary.html#aeae2c7a4f5ff9fae7abca41b1ea0042c">refs_on_dictstack_</a>.</p>

</div>
</div>
<a class="anchor" id="ac6272d6b81f9df2adc740118634c68fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dictionary::known </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="className.html">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classlibrandom_1_1GslRandomGen.html#a310ca668d42388c8a49256e7d65d12f2">librandom::GslRandomGen::add_gsl_rngs()</a>, <a class="el" href="classnest_1_1ConnBuilder.html#a2473965c5fe034f0bff6409d171129d9">nest::ConnBuilder::ConnBuilder()</a>, <a class="el" href="classnest_1_1Network.html#a64c295c43d81dd884189203f911b2301">nest::Network::connect()</a>, <a class="el" href="classnest_1_1Network.html#a23a5d25f4416daaf084f2d5f3499c33e">nest::Network::copy_model()</a>, <a class="el" href="classnest_1_1NestModule_1_1CopyModel__l__l__DFunction.html#a5e78671fc277aea54985185a88e85fe3">nest::NestModule::CopyModel_l_l_DFunction::execute()</a>, <a class="el" href="classSLIInterpreter.html#a1d4268e9a4b8064b77e12fba24d15620">SLIInterpreter::execute_()</a>, <a class="el" href="classSLIInterpreter.html#a2e551e6c11e2e8158d163e2b5996c33d">SLIInterpreter::execute_debug_()</a>, <a class="el" href="classSLIInterpreter.html#a1f76b68c473ace082511ddaa9eca5733">SLIInterpreter::print_error()</a>, <a class="el" href="group__SLIError.html#gac13fa0ddc13dfcd5b3c0c7116e10cdac">SLIInterpreter::raiseagain()</a>, <a class="el" href="classnest_1_1RandomParameter.html#a54a749f812298aebeb99802e60605a7c">nest::RandomParameter::RandomParameter()</a>, <a class="el" href="classnest_1_1Network.html#abe8cae03294b4e5d56fe7f70fba26381">nest::Network::register_basis_model()</a>, <a class="el" href="classnest_1_1Network.html#a41f45c4e00263c4dcfac919efa2fab27">nest::Network::register_conn_builder()</a>, <a class="el" href="classnest_1_1Network.html#a0270f32871ef27b62dad37da238361ac">nest::Network::register_model()</a>, and <a class="el" href="classSLIInterpreter.html#a46a16463860bc84385c4b242778e8caa">SLIInterpreter::terminate()</a>.</p>

</div>
</div>
<a class="anchor" id="a4734127601ba07fb27540a68e5bab5c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dictionary::known_but_not_accessed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="className.html">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if name is known but token has not been accessed. </p>

</div>
</div>
<a class="anchor" id="abaa0e0b84d483fff3a4930fabb303d20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classToken.html">Token</a> &amp; Dictionary::lookup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="className.html">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup and return <a class="el" href="classToken.html" title="A type-independent container for C++-types. ">Token</a> with given name in dictionary. </p>
<p>If the name is not found, an empty token is returned. This version of lookup is deprecated and will disappear in future versions. Please use <a class="el" href="classDictionary.html#a088dd49df05e0a626c45cca14cb7e54a" title="lookup a name in the dictionary. ">lookup2()</a> instead. </p><dl class="section note"><dt>Note</dt><dd>The token returned should <b>always</b> be stored as a <code>const &amp;</code>, so that the control flag for dictionary read-out is set on the <a class="el" href="classToken.html" title="A type-independent container for C++-types. ">Token</a> in the dictionary, not its copy. </dd></dl>

<p>References <a class="el" href="classDictionary.html#aae99e575d88591825abd532f39ce92c5">VoidToken</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1ConnectionCreator.html#aba3b91642fb738809e096bb60678fb1f">nest::ConnectionCreator::ConnectionCreator()</a>, <a class="el" href="classnest_1_1AbstractLayer.html#ab666ae368b2039eff3fce26558194d76">nest::AbstractLayer::create_layer()</a>, <a class="el" href="classnest_1_1NestModule_1_1SetDefaults__l__DFunction.html#a7e82b1447bd9a6a34e0f73f1e496b6d1">nest::NestModule::SetDefaults_l_DFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1GetDefaults__lFunction.html#a6f3269bcbeed903d381ba07ac99ef40d">nest::NestModule::GetDefaults_lFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1CopyModel__l__l__DFunction.html#a5e78671fc277aea54985185a88e85fe3">nest::NestModule::CopyModel_l_l_DFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1Create__l__iFunction.html#a07cfa5ef083b2f4b73a05afb15c5686d">nest::NestModule::Create_l_iFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1DataConnect__i__D__sFunction.html#a86cf4180d8d6bdf42a3a3b95ea993bb3">nest::NestModule::DataConnect_i_D_sFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1Connect__i__i__lFunction.html#a693863c64a467f0133828b83238fe0f0">nest::NestModule::Connect_i_i_lFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1Connect__i__i__d__d__lFunction.html#a8a22bcb433ee35041fcad7c831e88ad9">nest::NestModule::Connect_i_i_d_d_lFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1Connect__i__i__D__lFunction.html#a986be82486342d9d25d51fcce28a3152">nest::NestModule::Connect_i_i_D_lFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1DivergentConnect__i__ia__a__a__lFunction.html#a1d7e46e538648ab2eeee6029a1ad2741">nest::NestModule::DivergentConnect_i_ia_a_a_lFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1RDivergentConnect__i__i__ia__da__da__b__b__lFunction.html#a75e2365bc9f69fbf6f54aadb7859c70b">nest::NestModule::RDivergentConnect_i_i_ia_da_da_b_b_lFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1ConvergentConnect__ia__i__a__a__lFunction.html#a9ca05b18ae8902a88d465254cf206533">nest::NestModule::ConvergentConnect_ia_i_a_a_lFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1RConvergentConnect__ia__i__i__da__da__b__b__lFunction.html#a5cc5863c8f7c272b96de1d4ae39bb635">nest::NestModule::RConvergentConnect_ia_i_i_da_da_b_b_lFunction::execute()</a>, <a class="el" href="classnest_1_1NestModule_1_1RConvergentConnect__ia__ia__ia__daa__daa__b__b__lFunction.html#ad8f76dce751868004e781834c7865c2e">nest::NestModule::RConvergentConnect_ia_ia_ia_daa_daa_b_b_lFunction::execute()</a>, <a class="el" href="classSLIInterpreter.html#a1f76b68c473ace082511ddaa9eca5733">SLIInterpreter::print_error()</a>, <a class="el" href="group__SLIError.html#gac13fa0ddc13dfcd5b3c0c7116e10cdac">SLIInterpreter::raiseagain()</a>, <a class="el" href="group__SLIError.html#ga098156501ff35f206a32d389bf262e05">SLIInterpreter::raiseerror()</a>, and <a class="el" href="structnest_1_1Selector.html#a1b3ae01bf382ef58a368684181877da9">nest::Selector::Selector()</a>.</p>

</div>
</div>
<a class="anchor" id="a088dd49df05e0a626c45cca14cb7e54a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classToken.html">Token</a> &amp; Dictionary::lookup2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="className.html">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lookup a name in the dictionary. </p>
<p>If the name is not found an <a class="el" href="classUndefinedName.html" title="Exception to be thrown if an entry referenced inside a dictionary does not exist. ...">UndefinedName</a> exception is thrown. lookup2 is the preferred way to retrieve entries from the dictionary. </p><dl class="section note"><dt>Note</dt><dd>The token returned should <b>always</b> be stored as a <code>const &amp;</code>, so that the control flag for dictionary read-out is set on the <a class="el" href="classToken.html" title="A type-independent container for C++-types. ">Token</a> in the dictionary, not its copy. </dd></dl>

<p>References <a class="el" href="className.html#a779b1a146fdbb2ed397e0c0adf2be299">Name::toString()</a>.</p>

</div>
</div>
<a class="anchor" id="a69652ade345979404aa4c06fd9e0d07a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dictionary::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDictionary.html">Dictionary</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="dict_8h.html#a1023fe3c893f106e462b1ad41b9ecc8d">operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a6b5c92768951c6d6b4329466b2bc1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classToken.html">Token</a> &amp; Dictionary::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="className.html">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="className.html#a779b1a146fdbb2ed397e0c0adf2be299">Name::toString()</a>.</p>

<p>Referenced by <a class="el" href="classDictionary.html#aeaa92cd3cc17be1f7740a4c55ca4f98d">operator[]()</a>.</p>

</div>
</div>
<a class="anchor" id="a95c46b8638f07bf47a2d3a6933acf197"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken.html">Token</a> &amp; Dictionary::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="className.html">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeaa92cd3cc17be1f7740a4c55ca4f98d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classToken.html">Token</a> &amp; Dictionary::operator[] </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="classDictionary.html#a7a6b5c92768951c6d6b4329466b2bc1e">operator[]()</a>.</p>

</div>
</div>
<a class="anchor" id="a27d1e3406daa9907edc2fbdd8dc01eb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken.html">Token</a> &amp; Dictionary::operator[] </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="classDictionary.html#a7a6b5c92768951c6d6b4329466b2bc1e">operator[]()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2e425e8074008a20138010e513023b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dictionary::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="className.html">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove entry from dictionary. </p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a0483b5ea6a07fab19789d65ed790e152">nest::Network::unregister_model()</a>.</p>

</div>
</div>
<a class="anchor" id="a906120ec1c4f9ecc2fe449c39647862e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dictionary::remove_dict </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSLIInterpreter.html">SLIInterpreter</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove entries found in another dictionary from this. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDictionary.html#a3c26795421861bc5ab7e14cab352a97d" title="Add the contents of this dictionary to another. ">add_dict</a> </dd></dl>

<p>References <a class="el" href="classSLIInterpreter.html#afc60171047178064e02ff2814c99c472">SLIInterpreter::baselookup()</a>, and <a class="el" href="namespacenest_1_1names.html#ab8c67898fb04b2e13acb81c4d2b5bcdb">nest::names::d</a>.</p>

</div>
</div>
<a class="anchor" id="ab002288fb70b83c59be633ed57627775"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dictionary::remove_dictstack_reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is called when the dictionary is popped from the dictionary stack. </p>

<p>References <a class="el" href="classDictionary.html#aeae2c7a4f5ff9fae7abca41b1ea0042c">refs_on_dictstack_</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a59fdec7c54658e2fbbec8234d30898d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDictionary.html">Dictionary</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aeae2c7a4f5ff9fae7abca41b1ea0042c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dictionary::refs_on_dictstack_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker function checking whether all elements have been accessed. </p>
<p>Checks nested dictionaries recursively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::string&amp;</td><td>contains string with names of non-accessed entries </td></tr>
    <tr><td class="paramname">std::string</td><td>prefix for nested dictionary entries, built during recursion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all dictionary elements have been accessed </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this is just the worker for <a class="el" href="classDictionary.html#ad8650ae2f1460128136140c7442908bf" title="Check whether all elements have been accessed. ">all_accessed()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDictionary.html#a0e7c9604b0bdb71c173e53f0bcccfe30" title="Clear access flags on all dictionary elements. ">clear_access_flags()</a>, <a class="el" href="classDictionary.html#ad8650ae2f1460128136140c7442908bf" title="Check whether all elements have been accessed. ">all_accessed()</a> </dd></dl>

<p>Referenced by <a class="el" href="classDictionary.html#a035abf800f0d6db67a73b59c411e6ace">add_dictstack_reference()</a>, <a class="el" href="classDictionary.html#ab608677790e05f263d8d4ffb8c75e085">is_on_dictstack()</a>, and <a class="el" href="classDictionary.html#ab002288fb70b83c59be633ed57627775">remove_dictstack_reference()</a>.</p>

</div>
</div>
<a class="anchor" id="aae99e575d88591825abd532f39ce92c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classToken.html">Token</a> Dictionary::VoidToken</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classDictionary.html#abaa0e0b84d483fff3a4930fabb303d20">lookup()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="dict_8h_source.html">dict.h</a></li>
<li><a class="el" href="dict_8cc.html">dict.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 26 2015 08:02:28 for NEST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
