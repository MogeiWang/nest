<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>NEST: nest::Scheduler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NEST
   &#160;<span id="projectnumber">2.6.0,not_revisioned_source_dir@0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenest.html">nest</a></li><li class="navelem"><a class="el" href="classnest_1_1Scheduler.html">Scheduler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classnest_1_1Scheduler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nest::Scheduler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Schedule update of Nodes and Events during simulation.  
 <a href="classnest_1_1Scheduler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="scheduler_8h_source.html">scheduler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6580ac2df0b26a1cb81880bb4d8623b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a6580ac2df0b26a1cb81880bb4d8623b7">Scheduler</a> (<a class="el" href="classnest_1_1Network.html">Network</a> &amp;)</td></tr>
<tr class="separator:a6580ac2df0b26a1cb81880bb4d8623b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5390cf239aa3e817bbcd8be021fc7bf2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a5390cf239aa3e817bbcd8be021fc7bf2">~Scheduler</a> ()</td></tr>
<tr class="separator:a5390cf239aa3e817bbcd8be021fc7bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4535609ec782a4197cfd8f9e82c81ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#af4535609ec782a4197cfd8f9e82c81ed">reset</a> ()</td></tr>
<tr class="memdesc:af4535609ec782a4197cfd8f9e82c81ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bring scheduler back to its initial state.  <a href="#af4535609ec782a4197cfd8f9e82c81ed">More...</a><br /></td></tr>
<tr class="separator:af4535609ec782a4197cfd8f9e82c81ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e60a0ad5602cf32c5d53b22764e9e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#aa3e60a0ad5602cf32c5d53b22764e9e8">clear_pending_spikes</a> ()</td></tr>
<tr class="memdesc:aa3e60a0ad5602cf32c5d53b22764e9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all pending spikes, but do not otherwise manipulate scheduler.  <a href="#aa3e60a0ad5602cf32c5d53b22764e9e8">More...</a><br /></td></tr>
<tr class="separator:aa3e60a0ad5602cf32c5d53b22764e9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a00f3e4a682ae9e7953f686f2a7e86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a36a00f3e4a682ae9e7953f686f2a7e86">simulate</a> (<a class="el" href="classnest_1_1Time.html">Time</a> const &amp;)</td></tr>
<tr class="memdesc:a36a00f3e4a682ae9e7953f686f2a7e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate for the given time .  <a href="#a36a00f3e4a682ae9e7953f686f2a7e86">More...</a><br /></td></tr>
<tr class="separator:a36a00f3e4a682ae9e7953f686f2a7e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe1af081c5bbace35baf209d8caead2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a2fe1af081c5bbace35baf209d8caead2">resume</a> ()</td></tr>
<tr class="memdesc:a2fe1af081c5bbace35baf209d8caead2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume simulation after an interrupt.  <a href="#a2fe1af081c5bbace35baf209d8caead2">More...</a><br /></td></tr>
<tr class="separator:a2fe1af081c5bbace35baf209d8caead2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0667834bfe78b86bbcad103a9bdb1d40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a0667834bfe78b86bbcad103a9bdb1d40">prepare_simulation</a> ()</td></tr>
<tr class="memdesc:a0667834bfe78b86bbcad103a9bdb1d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">All steps that must be done before a simulation.  <a href="#a0667834bfe78b86bbcad103a9bdb1d40">More...</a><br /></td></tr>
<tr class="separator:a0667834bfe78b86bbcad103a9bdb1d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a05f8027a8f1c337f5bbe4ac70aa12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a85a05f8027a8f1c337f5bbe4ac70aa12">finalize_simulation</a> ()</td></tr>
<tr class="memdesc:a85a05f8027a8f1c337f5bbe4ac70aa12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup after the simulation.  <a href="#a85a05f8027a8f1c337f5bbe4ac70aa12">More...</a><br /></td></tr>
<tr class="separator:a85a05f8027a8f1c337f5bbe4ac70aa12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61af144516a230948e193bd492b56e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ac61af144516a230948e193bd492b56e8">terminate</a> ()</td></tr>
<tr class="separator:ac61af144516a230948e193bd492b56e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339e5109da9de77cbfde2a78787ad8bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a339e5109da9de77cbfde2a78787ad8bf">send_remote</a> (<a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> p, <a class="el" href="classnest_1_1SpikeEvent.html">SpikeEvent</a> &amp;, const <a class="el" href="namespacenest.html#a042890c99221c8143a36ca44fea0f8f8">long_t</a> lag=0)</td></tr>
<tr class="memdesc:a339e5109da9de77cbfde2a78787ad8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add global id of event sender to the spike_register.  <a href="#a339e5109da9de77cbfde2a78787ad8bf">More...</a><br /></td></tr>
<tr class="separator:a339e5109da9de77cbfde2a78787ad8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a63fa3f4e64ad9d8dc2ba38c64ec4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a79a63fa3f4e64ad9d8dc2ba38c64ec4a">send_offgrid_remote</a> (<a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> p, <a class="el" href="classnest_1_1SpikeEvent.html">SpikeEvent</a> &amp;, const <a class="el" href="namespacenest.html#a042890c99221c8143a36ca44fea0f8f8">long_t</a> lag=0)</td></tr>
<tr class="memdesc:a79a63fa3f4e64ad9d8dc2ba38c64ec4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add global id of event sender to the spike_register.  <a href="#a79a63fa3f4e64ad9d8dc2ba38c64ec4a">More...</a><br /></td></tr>
<tr class="separator:a79a63fa3f4e64ad9d8dc2ba38c64ec4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7da977c215808e0b733e2cf7f9fd5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnest_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a7d7da977c215808e0b733e2cf7f9fd5e">thread_lid_to_node</a> (<a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> t, <a class="el" href="namespacenest.html#adad102550a6102c0c0bea1d1083a233f">targetindex</a> thread_local_id) const </td></tr>
<tr class="separator:a7d7da977c215808e0b733e2cf7f9fd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d76ffe59a674644bad7a5a3f3490a8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a3d76ffe59a674644bad7a5a3f3490a8c">get_num_threads</a> () const </td></tr>
<tr class="memdesc:a3d76ffe59a674644bad7a5a3f3490a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of threads used during simulation.  <a href="#a3d76ffe59a674644bad7a5a3f3490a8c">More...</a><br /></td></tr>
<tr class="separator:a3d76ffe59a674644bad7a5a3f3490a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab191f093886075861ce4ff1fbd41870e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ab191f093886075861ce4ff1fbd41870e">set_num_threads</a> (<a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> n_threads)</td></tr>
<tr class="memdesc:ab191f093886075861ce4ff1fbd41870e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of threads by setting the internal variable n_threads_, the corresponding value in the <a class="el" href="classnest_1_1Communicator.html">Communicator</a>, and the OpenMP number of threads.  <a href="#ab191f093886075861ce4ff1fbd41870e">More...</a><br /></td></tr>
<tr class="separator:ab191f093886075861ce4ff1fbd41870e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c271240fe80ca88325da59361ae76a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a71c271240fe80ca88325da59361ae76a">get_num_processes</a> () const </td></tr>
<tr class="memdesc:a71c271240fe80ca88325da59361ae76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of processes used during simulation.  <a href="#a71c271240fe80ca88325da59361ae76a">More...</a><br /></td></tr>
<tr class="separator:a71c271240fe80ca88325da59361ae76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e52f5b1ab7b4435dc6a5d6c2b189f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a6e52f5b1ab7b4435dc6a5d6c2b189f16">get_num_rec_processes</a> () const </td></tr>
<tr class="separator:a6e52f5b1ab7b4435dc6a5d6c2b189f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773c5563d8698e1e5b6cb100bc380672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a773c5563d8698e1e5b6cb100bc380672">get_num_sim_processes</a> () const </td></tr>
<tr class="separator:a773c5563d8698e1e5b6cb100bc380672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7d1d094655d23590cb6458224e0f3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a5d7d1d094655d23590cb6458224e0f3d">set_num_rec_processes</a> (int nrp, bool called_by_reset=false)</td></tr>
<tr class="memdesc:a5d7d1d094655d23590cb6458224e0f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set number of recording processes, switches NEST to global spike detection mode.  <a href="#a5d7d1d094655d23590cb6458224e0f3d">More...</a><br /></td></tr>
<tr class="separator:a5d7d1d094655d23590cb6458224e0f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a7079fdc016a3cc3b33cdb9a262dfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#af6a7079fdc016a3cc3b33cdb9a262dfa">increment_n_gsd</a> ()</td></tr>
<tr class="memdesc:af6a7079fdc016a3cc3b33cdb9a262dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment total number of global spike detectors by 1.  <a href="#af6a7079fdc016a3cc3b33cdb9a262dfa">More...</a><br /></td></tr>
<tr class="separator:af6a7079fdc016a3cc3b33cdb9a262dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a7acbcfd0d22d5caad27575137a102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a41a7acbcfd0d22d5caad27575137a102">get_n_gsd</a> ()</td></tr>
<tr class="memdesc:a41a7acbcfd0d22d5caad27575137a102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total number of global spike detectors.  <a href="#a41a7acbcfd0d22d5caad27575137a102">More...</a><br /></td></tr>
<tr class="separator:a41a7acbcfd0d22d5caad27575137a102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4363b41b34c9f751c3e000de561c0bc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a4363b41b34c9f751c3e000de561c0bc7">is_local_node</a> (<a class="el" href="classnest_1_1Node.html">Node</a> *) const </td></tr>
<tr class="memdesc:a4363b41b34c9f751c3e000de561c0bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the node on the local machine, false if not.  <a href="#a4363b41b34c9f751c3e000de561c0bc7">More...</a><br /></td></tr>
<tr class="separator:a4363b41b34c9f751c3e000de561c0bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1e97429fdce6ce2485f6d790bf0320"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a9c1e97429fdce6ce2485f6d790bf0320">is_local_vp</a> (<a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>) const </td></tr>
<tr class="memdesc:a9c1e97429fdce6ce2485f6d790bf0320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the thread is on the local machine, false if not.  <a href="#a9c1e97429fdce6ce2485f6d790bf0320">More...</a><br /></td></tr>
<tr class="separator:a9c1e97429fdce6ce2485f6d790bf0320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15767831fa857d512e6ffd2f5a36e8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a15767831fa857d512e6ffd2f5a36e8a1">suggest_vp</a> (<a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a> gid) const </td></tr>
<tr class="memdesc:a15767831fa857d512e6ffd2f5a36e8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a thread number for a given global node id.  <a href="#a15767831fa857d512e6ffd2f5a36e8a1">More...</a><br /></td></tr>
<tr class="separator:a15767831fa857d512e6ffd2f5a36e8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5f137ca1a086183e294f8f93fdfed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#acb5f137ca1a086183e294f8f93fdfed4">suggest_rec_vp</a> (<a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a> gid) const </td></tr>
<tr class="memdesc:acb5f137ca1a086183e294f8f93fdfed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a thread number for a given global recording node id.  <a href="#acb5f137ca1a086183e294f8f93fdfed4">More...</a><br /></td></tr>
<tr class="separator:acb5f137ca1a086183e294f8f93fdfed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73766c296b7a760ccd42a30a9faaeb56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a73766c296b7a760ccd42a30a9faaeb56">vp_to_thread</a> (<a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> vp) const </td></tr>
<tr class="separator:a73766c296b7a760ccd42a30a9faaeb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c27ab18ac3c210e7b482b8bde0dc1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ac1c27ab18ac3c210e7b482b8bde0dc1d">thread_to_vp</a> (<a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> t) const </td></tr>
<tr class="separator:ac1c27ab18ac3c210e7b482b8bde0dc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab91a31e7f70b27c9d9250345b1d357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#acab91a31e7f70b27c9d9250345b1d357">get_global_thread_id</a> (<a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> lt) const </td></tr>
<tr class="memdesc:acab91a31e7f70b27c9d9250345b1d357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global thread id of a local thread.  <a href="#acab91a31e7f70b27c9d9250345b1d357">More...</a><br /></td></tr>
<tr class="separator:acab91a31e7f70b27c9d9250345b1d357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5355ece7b55a2bebd5c4d20f68b6c0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ad5355ece7b55a2bebd5c4d20f68b6c0a">get_process_id</a> (<a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> vp) const </td></tr>
<tr class="memdesc:ad5355ece7b55a2bebd5c4d20f68b6c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the process id for a given virtual process.  <a href="#ad5355ece7b55a2bebd5c4d20f68b6c0a">More...</a><br /></td></tr>
<tr class="separator:ad5355ece7b55a2bebd5c4d20f68b6c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba04d6294b55cd3e28f87f6e5abe27ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#aba04d6294b55cd3e28f87f6e5abe27ab">get_simulated</a> () const </td></tr>
<tr class="memdesc:aba04d6294b55cd3e28f87f6e5abe27ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true, if the network has already been simulated for some time.  <a href="#aba04d6294b55cd3e28f87f6e5abe27ab">More...</a><br /></td></tr>
<tr class="separator:aba04d6294b55cd3e28f87f6e5abe27ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2154aa76e166b576b67b034a10587a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a2154aa76e166b576b67b034a10587a31">set_off_grid_communication</a> (bool off_grid_spiking)</td></tr>
<tr class="memdesc:a2154aa76e166b576b67b034a10587a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">set communication style to off_grid (true) or on_grid  <a href="#a2154aa76e166b576b67b034a10587a31">More...</a><br /></td></tr>
<tr class="separator:a2154aa76e166b576b67b034a10587a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcb6daba4b4a0bf6f956b08ae23cbbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#afbcb6daba4b4a0bf6f956b08ae23cbbd">get_off_grid_communication</a> () const </td></tr>
<tr class="memdesc:afbcb6daba4b4a0bf6f956b08ae23cbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">return current communication style.  <a href="#afbcb6daba4b4a0bf6f956b08ae23cbbd">More...</a><br /></td></tr>
<tr class="separator:afbcb6daba4b4a0bf6f956b08ae23cbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3ae781496ab08b5bd3b3d6aa19bc75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnest_1_1Time.html">Time</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a4c3ae781496ab08b5bd3b3d6aa19bc75">get_slice_origin</a> () const </td></tr>
<tr class="memdesc:a4c3ae781496ab08b5bd3b3d6aa19bc75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnest_1_1Time.html">Time</a> at beginning of current slice.  <a href="#a4c3ae781496ab08b5bd3b3d6aa19bc75">More...</a><br /></td></tr>
<tr class="separator:a4c3ae781496ab08b5bd3b3d6aa19bc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69e7c5d2296bf0d49f16019d8e1d9aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnest_1_1Time.html">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#af69e7c5d2296bf0d49f16019d8e1d9aa">get_previous_slice_origin</a> () const </td></tr>
<tr class="memdesc:af69e7c5d2296bf0d49f16019d8e1d9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnest_1_1Time.html">Time</a> at beginning of previous slice.  <a href="#af69e7c5d2296bf0d49f16019d8e1d9aa">More...</a><br /></td></tr>
<tr class="separator:af69e7c5d2296bf0d49f16019d8e1d9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e499ed37893d4f3198493adea8ff69a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnest_1_1Time.html">Time</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a8e499ed37893d4f3198493adea8ff69a">get_time</a> () const </td></tr>
<tr class="memdesc:a8e499ed37893d4f3198493adea8ff69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precise time of simulation.  <a href="#a8e499ed37893d4f3198493adea8ff69a">More...</a><br /></td></tr>
<tr class="separator:a8e499ed37893d4f3198493adea8ff69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60d36339f1f8b20722f362ee3159873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ab60d36339f1f8b20722f362ee3159873">update</a> ()</td></tr>
<tr class="memdesc:ab60d36339f1f8b20722f362ee3159873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all non-frozen nodes.  <a href="#ab60d36339f1f8b20722f362ee3159873">More...</a><br /></td></tr>
<tr class="separator:ab60d36339f1f8b20722f362ee3159873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e52e4f10ae9215bd1f192ec42080be7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a5e52e4f10ae9215bd1f192ec42080be7">set_network_</a> (<a class="el" href="classnest_1_1Network.html">Network</a> *)</td></tr>
<tr class="separator:a5e52e4f10ae9215bd1f192ec42080be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5d984bb02ef184bd0817fca5b572be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#aef5d984bb02ef184bd0817fca5b572be">set_status</a> (const <a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;)</td></tr>
<tr class="separator:aef5d984bb02ef184bd0817fca5b572be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780633ebfbaf31dca3e4951697de1743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a780633ebfbaf31dca3e4951697de1743">get_status</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;) const </td></tr>
<tr class="separator:a780633ebfbaf31dca3e4951697de1743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc868750e306521a792603dd3e927f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibrandom.html#a0cb7edb075a0524ec56bb214debecebf">librandom::RngPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a5cc868750e306521a792603dd3e927f5">get_rng</a> (const <a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>) const </td></tr>
<tr class="memdesc:a5cc868750e306521a792603dd3e927f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to random number generator of the specified thread.  <a href="#a5cc868750e306521a792603dd3e927f5">More...</a><br /></td></tr>
<tr class="separator:a5cc868750e306521a792603dd3e927f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5594ab26b725212463c543f76354f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibrandom.html#a0cb7edb075a0524ec56bb214debecebf">librandom::RngPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ab5594ab26b725212463c543f76354f56">get_grng</a> () const </td></tr>
<tr class="memdesc:ab5594ab26b725212463c543f76354f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to global random number generator.  <a href="#ab5594ab26b725212463c543f76354f56">More...</a><br /></td></tr>
<tr class="separator:ab5594ab26b725212463c543f76354f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc830cf29abc1eda6ac6b3c3d0b32445"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#abc830cf29abc1eda6ac6b3c3d0b32445">get_slice</a> () const </td></tr>
<tr class="memdesc:abc830cf29abc1eda6ac6b3c3d0b32445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get slice number.  <a href="#abc830cf29abc1eda6ac6b3c3d0b32445">More...</a><br /></td></tr>
<tr class="separator:abc830cf29abc1eda6ac6b3c3d0b32445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faa23ac781ba9c16ee3c1f61fe96b93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a9faa23ac781ba9c16ee3c1f61fe96b93">calibrate_clock</a> ()</td></tr>
<tr class="memdesc:a9faa23ac781ba9c16ee3c1f61fe96b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate clock after resolution change.  <a href="#a9faa23ac781ba9c16ee3c1f61fe96b93">More...</a><br /></td></tr>
<tr class="separator:a9faa23ac781ba9c16ee3c1f61fe96b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4aca840199490409ffaf0898bda61b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#abd4aca840199490409ffaf0898bda61b">ensure_valid_thread_local_ids</a> ()</td></tr>
<tr class="memdesc:abd4aca840199490409ffaf0898bda61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that all nodes in the network have valid thread-local IDs.  <a href="#abd4aca840199490409ffaf0898bda61b">More...</a><br /></td></tr>
<tr class="separator:abd4aca840199490409ffaf0898bda61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6f1d76d40b068c9b0f382aaaa2f0c91e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a6f1d76d40b068c9b0f382aaaa2f0c91e">get_modulo</a> (<a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> d)</td></tr>
<tr class="memdesc:a6f1d76d40b068c9b0f382aaaa2f0c91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (T+d) mod max_delay.  <a href="#a6f1d76d40b068c9b0f382aaaa2f0c91e">More...</a><br /></td></tr>
<tr class="separator:a6f1d76d40b068c9b0f382aaaa2f0c91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab6b144f7579e5507d0386f9bb4f1c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#aeab6b144f7579e5507d0386f9bb4f1c6">get_slice_modulo</a> (<a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> d)</td></tr>
<tr class="memdesc:aeab6b144f7579e5507d0386f9bb4f1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index to slice-based buffer.  <a href="#aeab6b144f7579e5507d0386f9bb4f1c6">More...</a><br /></td></tr>
<tr class="separator:aeab6b144f7579e5507d0386f9bb4f1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69636427b011c4f9526c5247a5697291"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a69636427b011c4f9526c5247a5697291">get_min_delay</a> ()</td></tr>
<tr class="memdesc:a69636427b011c4f9526c5247a5697291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return minimal connection delay.  <a href="#a69636427b011c4f9526c5247a5697291">More...</a><br /></td></tr>
<tr class="separator:a69636427b011c4f9526c5247a5697291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad575de8f6e5184376aeea4cc37e73a57"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ad575de8f6e5184376aeea4cc37e73a57">get_max_delay</a> ()</td></tr>
<tr class="memdesc:ad575de8f6e5184376aeea4cc37e73a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximal connection delay.  <a href="#ad575de8f6e5184376aeea4cc37e73a57">More...</a><br /></td></tr>
<tr class="separator:ad575de8f6e5184376aeea4cc37e73a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a53f840c664a675044983325fab047d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a53f840c664a675044983325fab047d4e">init_</a> ()</td></tr>
<tr class="memdesc:a53f840c664a675044983325fab047d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the scheduler by initializing the buffers.  <a href="#a53f840c664a675044983325fab047d4e">More...</a><br /></td></tr>
<tr class="separator:a53f840c664a675044983325fab047d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39db01982170b28bd22dbe2f7ef88565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a39db01982170b28bd22dbe2f7ef88565">finalize_</a> ()</td></tr>
<tr class="memdesc:a39db01982170b28bd22dbe2f7ef88565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the scheduler by freeing the buffers and destoying the mutexes.  <a href="#a39db01982170b28bd22dbe2f7ef88565">More...</a><br /></td></tr>
<tr class="separator:a39db01982170b28bd22dbe2f7ef88565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b3c6274aa230606859cda08ad4153e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a53b3c6274aa230606859cda08ad4153e">advance_time_</a> ()</td></tr>
<tr class="separator:a53b3c6274aa230606859cda08ad4153e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb34fd63baadef7f8918dfe854807cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a7eb34fd63baadef7f8918dfe854807cb">print_progress_</a> ()</td></tr>
<tr class="separator:a7eb34fd63baadef7f8918dfe854807cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2012a54b09a2754aef94ba533818f611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes</a> ()</td></tr>
<tr class="memdesc:a2012a54b09a2754aef94ba533818f611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare nodes for simulation and register nodes in node_list.  <a href="#a2012a54b09a2754aef94ba533818f611">More...</a><br /></td></tr>
<tr class="separator:a2012a54b09a2754aef94ba533818f611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7430a023de77c7dd90dda0596163315f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a7430a023de77c7dd90dda0596163315f">prepare_node_</a> (<a class="el" href="classnest_1_1Node.html">Node</a> *)</td></tr>
<tr class="memdesc:a7430a023de77c7dd90dda0596163315f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialized buffers, register in list of nodes to update/finalize.  <a href="#a7430a023de77c7dd90dda0596163315f">More...</a><br /></td></tr>
<tr class="separator:a7430a023de77c7dd90dda0596163315f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde400fb8211824aa354ec1aee951b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#abde400fb8211824aa354ec1aee951b09">finalize_nodes</a> ()</td></tr>
<tr class="memdesc:abde400fb8211824aa354ec1aee951b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke finalize() on nodes registered for finalization.  <a href="#abde400fb8211824aa354ec1aee951b09">More...</a><br /></td></tr>
<tr class="separator:abde400fb8211824aa354ec1aee951b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e05baa2e0c527bfb3888f2cbefcec39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a5e05baa2e0c527bfb3888f2cbefcec39">compute_moduli_</a> ()</td></tr>
<tr class="memdesc:a5e05baa2e0c527bfb3888f2cbefcec39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-compute table of fixed modulos, including slice-based.  <a href="#a5e05baa2e0c527bfb3888f2cbefcec39">More...</a><br /></td></tr>
<tr class="separator:a5e05baa2e0c527bfb3888f2cbefcec39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a865a6fdae2053a09becf571631589c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a1a865a6fdae2053a09becf571631589c">init_moduli_</a> ()</td></tr>
<tr class="separator:a1a865a6fdae2053a09becf571631589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfbb4c585b05dc8af93b22213f12fd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#addfbb4c585b05dc8af93b22213f12fd0">create_rngs_</a> (const bool ctor_call=false)</td></tr>
<tr class="separator:addfbb4c585b05dc8af93b22213f12fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334f833f9cbadaca9566337ae8e265da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a334f833f9cbadaca9566337ae8e265da">create_grng_</a> (const bool ctor_call=false)</td></tr>
<tr class="separator:a334f833f9cbadaca9566337ae8e265da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f6d8545e9b67a406e1a8c8bb8db967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a77f6d8545e9b67a406e1a8c8bb8db967">configure_spike_buffers_</a> ()</td></tr>
<tr class="memdesc:a77f6d8545e9b67a406e1a8c8bb8db967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize spike_register and comm_buffer to correct dimensions.  <a href="#a77f6d8545e9b67a406e1a8c8bb8db967">More...</a><br /></td></tr>
<tr class="separator:a77f6d8545e9b67a406e1a8c8bb8db967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbea3477ba17af320a0974b03add2791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#afbea3477ba17af320a0974b03add2791">update_nodes_vec_</a> ()</td></tr>
<tr class="memdesc:afbea3477ba17af320a0974b03add2791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create up-to-date vector of local nodes, nodes_vec_.  <a href="#afbea3477ba17af320a0974b03add2791">More...</a><br /></td></tr>
<tr class="separator:afbea3477ba17af320a0974b03add2791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff16451fe1f6be31b46c2b5de9a5332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#acff16451fe1f6be31b46c2b5de9a5332">collocate_buffers_</a> ()</td></tr>
<tr class="memdesc:acff16451fe1f6be31b46c2b5de9a5332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearrange the spike_register into a 2-dim structure.  <a href="#acff16451fe1f6be31b46c2b5de9a5332">More...</a><br /></td></tr>
<tr class="separator:acff16451fe1f6be31b46c2b5de9a5332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25106abd95c518669e27ebe8e49c555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#af25106abd95c518669e27ebe8e49c555">gather_events_</a> ()</td></tr>
<tr class="memdesc:af25106abd95c518669e27ebe8e49c555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collocate buffers and exchange events with other MPI processes.  <a href="#af25106abd95c518669e27ebe8e49c555">More...</a><br /></td></tr>
<tr class="separator:af25106abd95c518669e27ebe8e49c555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe64b26dcbf4e453d57b05f22d2c75e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a4fe64b26dcbf4e453d57b05f22d2c75e">deliver_events_</a> (<a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> t)</td></tr>
<tr class="memdesc:a4fe64b26dcbf4e453d57b05f22d2c75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all event buffers for thread t and send the corresponding Events to the Nodes that are targeted.  <a href="#a4fe64b26dcbf4e453d57b05f22d2c75e">More...</a><br /></td></tr>
<tr class="separator:a4fe64b26dcbf4e453d57b05f22d2c75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a3cc8d4b2402923099701cd2fa267be43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a3cc8d4b2402923099701cd2fa267be43">update_delay_extrema_</a> ()</td></tr>
<tr class="memdesc:a3cc8d4b2402923099701cd2fa267be43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update delay extrema to current values.  <a href="#a3cc8d4b2402923099701cd2fa267be43">More...</a><br /></td></tr>
<tr class="separator:a3cc8d4b2402923099701cd2fa267be43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a73ea61977eac1e8bc6e62ae62734b4e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a73ea61977eac1e8bc6e62ae62734b4e7">initialized_</a></td></tr>
<tr class="separator:a73ea61977eac1e8bc6e62ae62734b4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce1c049d2ce4466ea370a77b02559f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a2ce1c049d2ce4466ea370a77b02559f3">simulating_</a></td></tr>
<tr class="memdesc:a2ce1c049d2ce4466ea370a77b02559f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if simulation in progress  <a href="#a2ce1c049d2ce4466ea370a77b02559f3">More...</a><br /></td></tr>
<tr class="separator:a2ce1c049d2ce4466ea370a77b02559f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8774dfba36b5ffd36a4fc538c9b74bad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a8774dfba36b5ffd36a4fc538c9b74bad">force_singlethreading_</a></td></tr>
<tr class="separator:a8774dfba36b5ffd36a4fc538c9b74bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf172b32fe078d03e9f84417a14d59b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#acf172b32fe078d03e9f84417a14d59b9">n_threads_</a></td></tr>
<tr class="memdesc:acf172b32fe078d03e9f84417a14d59b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads per process.  <a href="#acf172b32fe078d03e9f84417a14d59b9">More...</a><br /></td></tr>
<tr class="separator:acf172b32fe078d03e9f84417a14d59b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5d6a6280174d49f81902136bddd4f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a4e5d6a6280174d49f81902136bddd4f5">n_rec_procs_</a></td></tr>
<tr class="memdesc:a4e5d6a6280174d49f81902136bddd4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI processes dedicated for recording devices.  <a href="#a4e5d6a6280174d49f81902136bddd4f5">More...</a><br /></td></tr>
<tr class="separator:a4e5d6a6280174d49f81902136bddd4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcb9aed5378181477261e767423c57a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a0dcb9aed5378181477261e767423c57a">n_sim_procs_</a></td></tr>
<tr class="memdesc:a0dcb9aed5378181477261e767423c57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI processes used for simulation.  <a href="#a0dcb9aed5378181477261e767423c57a">More...</a><br /></td></tr>
<tr class="separator:a0dcb9aed5378181477261e767423c57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ab7eac504fa5c058b21b16ff06cddd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ab8ab7eac504fa5c058b21b16ff06cddd">n_gsd_</a></td></tr>
<tr class="memdesc:ab8ab7eac504fa5c058b21b16ff06cddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of global spike detectors, used for distributing them over recording processes.  <a href="#ab8ab7eac504fa5c058b21b16ff06cddd">More...</a><br /></td></tr>
<tr class="separator:ab8ab7eac504fa5c058b21b16ff06cddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfdcf14299bc184df4610925b4dce2e"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#afcfdcf14299bc184df4610925b4dce2e">entry_counter_</a></td></tr>
<tr class="memdesc:afcfdcf14299bc184df4610925b4dce2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter for entry barrier.  <a href="#afcfdcf14299bc184df4610925b4dce2e">More...</a><br /></td></tr>
<tr class="separator:afcfdcf14299bc184df4610925b4dce2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cb3fe86624b46340cff9387ca263f4"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ac9cb3fe86624b46340cff9387ca263f4">exit_counter_</a></td></tr>
<tr class="memdesc:ac9cb3fe86624b46340cff9387ca263f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter for exit barrier.  <a href="#ac9cb3fe86624b46340cff9387ca263f4">More...</a><br /></td></tr>
<tr class="separator:ac9cb3fe86624b46340cff9387ca263f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e4343087b672ab65880931a4a63b40"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; <a class="el" href="classnest_1_1Node.html">Node</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ab7e4343087b672ab65880931a4a63b40">nodes_vec_</a></td></tr>
<tr class="memdesc:ab7e4343087b672ab65880931a4a63b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodelists for nodes for each thread.  <a href="#ab7e4343087b672ab65880931a4a63b40">More...</a><br /></td></tr>
<tr class="separator:ab7e4343087b672ab65880931a4a63b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744beca957a26904f88f2d0fa8a77d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a744beca957a26904f88f2d0fa8a77d9c">nodes_vec_network_size_</a></td></tr>
<tr class="memdesc:a744beca957a26904f88f2d0fa8a77d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnest_1_1Network.html" title="Main administrative interface to the network. ">Network</a> size when nodes_vec_ was last updated.  <a href="#a744beca957a26904f88f2d0fa8a77d9c">More...</a><br /></td></tr>
<tr class="separator:a744beca957a26904f88f2d0fa8a77d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7205913a1117826b5c957717334547c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnest_1_1Time.html">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a7205913a1117826b5c957717334547c5">clock_</a></td></tr>
<tr class="memdesc:a7205913a1117826b5c957717334547c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnest_1_1Network.html" title="Main administrative interface to the network. ">Network</a> clock, updated once per slice.  <a href="#a7205913a1117826b5c957717334547c5">More...</a><br /></td></tr>
<tr class="separator:a7205913a1117826b5c957717334547c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86997c3d01d9f2d60b467be498ff4b19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a86997c3d01d9f2d60b467be498ff4b19">slice_</a></td></tr>
<tr class="memdesc:a86997c3d01d9f2d60b467be498ff4b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">current update slice  <a href="#a86997c3d01d9f2d60b467be498ff4b19">More...</a><br /></td></tr>
<tr class="separator:a86997c3d01d9f2d60b467be498ff4b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad158986b0786da045676391c73e7f7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ad158986b0786da045676391c73e7f7d9">to_do_</a></td></tr>
<tr class="memdesc:ad158986b0786da045676391c73e7f7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of pending cycles.  <a href="#ad158986b0786da045676391c73e7f7d9">More...</a><br /></td></tr>
<tr class="separator:ad158986b0786da045676391c73e7f7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62b93dabc57d753c774d8bc87cc2315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ab62b93dabc57d753c774d8bc87cc2315">to_do_total_</a></td></tr>
<tr class="memdesc:ab62b93dabc57d753c774d8bc87cc2315"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of requested cycles in current simulation.  <a href="#ab62b93dabc57d753c774d8bc87cc2315">More...</a><br /></td></tr>
<tr class="separator:ab62b93dabc57d753c774d8bc87cc2315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a538b918c6d2673f9aa12fc6600355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a50a538b918c6d2673f9aa12fc6600355">from_step_</a></td></tr>
<tr class="memdesc:a50a538b918c6d2673f9aa12fc6600355"><td class="mdescLeft">&#160;</td><td class="mdescRight">update clock_+from_step&lt;=T&lt;clock_+to_step_  <a href="#a50a538b918c6d2673f9aa12fc6600355">More...</a><br /></td></tr>
<tr class="separator:a50a538b918c6d2673f9aa12fc6600355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c8d251fbd9a3b99c638f2bc5a52042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a93c8d251fbd9a3b99c638f2bc5a52042">to_step_</a></td></tr>
<tr class="memdesc:a93c8d251fbd9a3b99c638f2bc5a52042"><td class="mdescLeft">&#160;</td><td class="mdescRight">update clock_+from_step&lt;=T&lt;clock_+to_step_  <a href="#a93c8d251fbd9a3b99c638f2bc5a52042">More...</a><br /></td></tr>
<tr class="separator:a93c8d251fbd9a3b99c638f2bc5a52042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591d802504ba8195c4f33fece633c683"><td class="memItemLeft" align="right" valign="top">timeval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a591d802504ba8195c4f33fece633c683">t_slice_begin_</a></td></tr>
<tr class="memdesc:a591d802504ba8195c4f33fece633c683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wall-clock time at the begin of a time slice.  <a href="#a591d802504ba8195c4f33fece633c683">More...</a><br /></td></tr>
<tr class="separator:a591d802504ba8195c4f33fece633c683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409db592d512b03564155c8244ca18aa"><td class="memItemLeft" align="right" valign="top">timeval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a409db592d512b03564155c8244ca18aa">t_slice_end_</a></td></tr>
<tr class="memdesc:a409db592d512b03564155c8244ca18aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wall-clock time at the end of time slice.  <a href="#a409db592d512b03564155c8244ca18aa">More...</a><br /></td></tr>
<tr class="separator:a409db592d512b03564155c8244ca18aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c81be0e25d1119664b4c7c35afa49e4"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a1c81be0e25d1119664b4c7c35afa49e4">t_real_</a></td></tr>
<tr class="memdesc:a1c81be0e25d1119664b4c7c35afa49e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumunated wall-clock time spent simulating (in us)  <a href="#a1c81be0e25d1119664b4c7c35afa49e4">More...</a><br /></td></tr>
<tr class="separator:a1c81be0e25d1119664b4c7c35afa49e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2532a56cee80e3532d9263cb8062b0d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a2532a56cee80e3532d9263cb8062b0d1">terminate_</a></td></tr>
<tr class="memdesc:a2532a56cee80e3532d9263cb8062b0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate on signal or error.  <a href="#a2532a56cee80e3532d9263cb8062b0d1">More...</a><br /></td></tr>
<tr class="separator:a2532a56cee80e3532d9263cb8062b0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef73b4dd8cdc93fd70d844796e53fd50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#aef73b4dd8cdc93fd70d844796e53fd50">simulated_</a></td></tr>
<tr class="memdesc:aef73b4dd8cdc93fd70d844796e53fd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates whether the network has already been simulated for some time  <a href="#aef73b4dd8cdc93fd70d844796e53fd50">More...</a><br /></td></tr>
<tr class="separator:aef73b4dd8cdc93fd70d844796e53fd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6992ac561695c21ed9e5c8945c335c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#af6992ac561695c21ed9e5c8945c335c9">off_grid_spiking_</a></td></tr>
<tr class="memdesc:af6992ac561695c21ed9e5c8945c335c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates whether spikes are not constrained to the grid  <a href="#af6992ac561695c21ed9e5c8945c335c9">More...</a><br /></td></tr>
<tr class="separator:af6992ac561695c21ed9e5c8945c335c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175e773656e38507c7eb7d941394989d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a175e773656e38507c7eb7d941394989d">print_time_</a></td></tr>
<tr class="memdesc:a175e773656e38507c7eb7d941394989d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether time should be printed during simulations (or not)  <a href="#a175e773656e38507c7eb7d941394989d">More...</a><br /></td></tr>
<tr class="separator:a175e773656e38507c7eb7d941394989d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d932367532ab0af064426d44db3c31e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenest.html#a042890c99221c8143a36ca44fea0f8f8">long_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a3d932367532ab0af064426d44db3c31e">rng_seeds_</a></td></tr>
<tr class="memdesc:a3d932367532ab0af064426d44db3c31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The seeds of the local RNGs. These do not neccessarily describe the state of the RNGs.  <a href="#a3d932367532ab0af064426d44db3c31e">More...</a><br /></td></tr>
<tr class="separator:a3d932367532ab0af064426d44db3c31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ba6d5c2dd71883933b8a8b7a5d7a06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenest.html#a042890c99221c8143a36ca44fea0f8f8">long_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a20ba6d5c2dd71883933b8a8b7a5d7a06">grng_seed_</a></td></tr>
<tr class="memdesc:a20ba6d5c2dd71883933b8a8b7a5d7a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">The seed of the global RNG, not neccessarily describing the state of the GRNG.  <a href="#a20ba6d5c2dd71883933b8a8b7a5d7a06">More...</a><br /></td></tr>
<tr class="separator:a20ba6d5c2dd71883933b8a8b7a5d7a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde3be9a92d240a2866eb4b8332ecfbd"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacelibrandom.html#a0cb7edb075a0524ec56bb214debecebf">librandom::RngPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#acde3be9a92d240a2866eb4b8332ecfbd">rng_</a></td></tr>
<tr class="memdesc:acde3be9a92d240a2866eb4b8332ecfbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of random number generators for threads.  <a href="#acde3be9a92d240a2866eb4b8332ecfbd">More...</a><br /></td></tr>
<tr class="separator:acde3be9a92d240a2866eb4b8332ecfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb43e28d8e81711289e16e8db278e924"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibrandom.html#a0cb7edb075a0524ec56bb214debecebf">librandom::RngPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#aeb43e28d8e81711289e16e8db278e924">grng_</a></td></tr>
<tr class="memdesc:aeb43e28d8e81711289e16e8db278e924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global random number generator.  <a href="#aeb43e28d8e81711289e16e8db278e924">More...</a><br /></td></tr>
<tr class="separator:aeb43e28d8e81711289e16e8db278e924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df87f171d097e16a64ab3ad8c55993d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak" />
&lt; std::vector&lt; <a class="el" href="namespacenest.html#af3860d4cd9794a72414678987b1cfcc8">uint_t</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a3df87f171d097e16a64ab3ad8c55993d">spike_register_</a></td></tr>
<tr class="memdesc:a3df87f171d097e16a64ab3ad8c55993d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register for gids of neurons that spiked.  <a href="#a3df87f171d097e16a64ab3ad8c55993d">More...</a><br /></td></tr>
<tr class="separator:a3df87f171d097e16a64ab3ad8c55993d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf398119a87288e7378158de10f473bc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak" />
&lt; std::vector&lt; <a class="el" href="namespacenest.html#a9ffcbdfc4ad79fd1bea02f80d34c99fe">OffGridSpike</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#adf398119a87288e7378158de10f473bc">offgrid_spike_register_</a></td></tr>
<tr class="memdesc:adf398119a87288e7378158de10f473bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register for off-grid spikes.  <a href="#adf398119a87288e7378158de10f473bc">More...</a><br /></td></tr>
<tr class="separator:adf398119a87288e7378158de10f473bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb59504ceab10064539890b324ae1395"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenest.html#af3860d4cd9794a72414678987b1cfcc8">uint_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#afb59504ceab10064539890b324ae1395">local_grid_spikes_</a></td></tr>
<tr class="memdesc:afb59504ceab10064539890b324ae1395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer containing the gids of local neurons that spiked in the last min_delay_ interval.  <a href="#afb59504ceab10064539890b324ae1395">More...</a><br /></td></tr>
<tr class="separator:afb59504ceab10064539890b324ae1395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2984af6a16d22178da3b91b467312ed8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenest.html#af3860d4cd9794a72414678987b1cfcc8">uint_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a2984af6a16d22178da3b91b467312ed8">global_grid_spikes_</a></td></tr>
<tr class="memdesc:a2984af6a16d22178da3b91b467312ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer containing the gids of all neurons that spiked in the last min_delay_ interval.  <a href="#a2984af6a16d22178da3b91b467312ed8">More...</a><br /></td></tr>
<tr class="separator:a2984af6a16d22178da3b91b467312ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacd816ad60eb43bfbe5a135979de678"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenest.html#a9ffcbdfc4ad79fd1bea02f80d34c99fe">OffGridSpike</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#adacd816ad60eb43bfbe5a135979de678">local_offgrid_spikes_</a></td></tr>
<tr class="memdesc:adacd816ad60eb43bfbe5a135979de678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer containing the gids and offsets for local neurons that fired off-grid spikes in the last min_delay_ interval.  <a href="#adacd816ad60eb43bfbe5a135979de678">More...</a><br /></td></tr>
<tr class="separator:adacd816ad60eb43bfbe5a135979de678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00226cd82de9f0fe7e5c2576421aa13"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenest.html#a9ffcbdfc4ad79fd1bea02f80d34c99fe">OffGridSpike</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ac00226cd82de9f0fe7e5c2576421aa13">global_offgrid_spikes_</a></td></tr>
<tr class="memdesc:ac00226cd82de9f0fe7e5c2576421aa13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer containing the gids and offsets for all neurons that fired off-grid spikes in the last min_delay_ interval.  <a href="#ac00226cd82de9f0fe7e5c2576421aa13">More...</a><br /></td></tr>
<tr class="separator:ac00226cd82de9f0fe7e5c2576421aa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e11627ff95327c6aa64397feff26b79"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a3e11627ff95327c6aa64397feff26b79">displacements_</a></td></tr>
<tr class="memdesc:a3e11627ff95327c6aa64397feff26b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer containing the starting positions for the spikes from each process within the global_(off)grid_spikes_ buffer.  <a href="#a3e11627ff95327c6aa64397feff26b79">More...</a><br /></td></tr>
<tr class="separator:a3e11627ff95327c6aa64397feff26b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a1e7e39b5342371664746e20ad56f1973"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnest_1_1Network.html">Network</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a1e7e39b5342371664746e20ad56f1973">net_</a> = 0</td></tr>
<tr class="memdesc:a1e7e39b5342371664746e20ad56f1973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to network object.  <a href="#a1e7e39b5342371664746e20ad56f1973">More...</a><br /></td></tr>
<tr class="separator:a1e7e39b5342371664746e20ad56f1973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9d71b493787f129713489a45a7591a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a6d9d71b493787f129713489a45a7591a">min_delay_</a> = 1</td></tr>
<tr class="memdesc:a6d9d71b493787f129713489a45a7591a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of the smallest delay in the network.  <a href="#a6d9d71b493787f129713489a45a7591a">More...</a><br /></td></tr>
<tr class="separator:a6d9d71b493787f129713489a45a7591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fdc3a261885b5f3d941dc04e81a8fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a91fdc3a261885b5f3d941dc04e81a8fa">max_delay_</a> = 1</td></tr>
<tr class="memdesc:a91fdc3a261885b5f3d941dc04e81a8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of the largest delay in the network.  <a href="#a91fdc3a261885b5f3d941dc04e81a8fa">More...</a><br /></td></tr>
<tr class="separator:a91fdc3a261885b5f3d941dc04e81a8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbd47c098e40222953ee35705084cf7"><td class="memItemLeft" align="right" valign="top">static vector&lt; <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#accbd47c098e40222953ee35705084cf7">moduli_</a></td></tr>
<tr class="memdesc:accbd47c098e40222953ee35705084cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of pre-computed modulos.  <a href="#accbd47c098e40222953ee35705084cf7">More...</a><br /></td></tr>
<tr class="separator:accbd47c098e40222953ee35705084cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d8621bac8d646f452bdf79fd2b5c33"><td class="memItemLeft" align="right" valign="top">static vector&lt; <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#ac9d8621bac8d646f452bdf79fd2b5c33">slice_moduli_</a></td></tr>
<tr class="memdesc:ac9d8621bac8d646f452bdf79fd2b5c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of pre-computed slice-based modulos.  <a href="#ac9d8621bac8d646f452bdf79fd2b5c33">More...</a><br /></td></tr>
<tr class="separator:ac9d8621bac8d646f452bdf79fd2b5c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573adb8c9ee29ed17d65d7bb9809f35d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnest_1_1Scheduler.html#a573adb8c9ee29ed17d65d7bb9809f35d">comm_marker_</a> = 0</td></tr>
<tr class="memdesc:a573adb8c9ee29ed17d65d7bb9809f35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker Value to be put between the data fields from different time steps during communication.  <a href="#a573adb8c9ee29ed17d65d7bb9809f35d">More...</a><br /></td></tr>
<tr class="separator:a573adb8c9ee29ed17d65d7bb9809f35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Schedule update of Nodes and Events during simulation. </p>
<p>The scheduler controls a number of threads which are responsible for updating a batch of Nodes independently from each other. The number of threads as well as the batch size of each thread can be configured with get_status and set_status methods.</p>
<p>The scheduler also controls the random number clients which are associated to the threads.</p>
<p>The scheduler is usually hidden inside the network class. Thus, its interface is of little interest to the "normal" model developer. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6580ac2df0b26a1cb81880bb4d8623b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nest::Scheduler::Scheduler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnest_1_1Network.html">Network</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="classnest_1_1Scheduler.html#a53f840c664a675044983325fab047d4e">init_()</a>, and <a class="el" href="classnest_1_1Scheduler.html#a1e7e39b5342371664746e20ad56f1973">net_</a>.</p>

</div>
</div>
<a class="anchor" id="a5390cf239aa3e817bbcd8be021fc7bf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nest::Scheduler::~Scheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a53b3c6274aa230606859cda08ad4153e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::advance_time_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>.</p>

</div>
</div>
<a class="anchor" id="a9faa23ac781ba9c16ee3c1f61fe96b93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::calibrate_clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calibrate clock after resolution change. </p>

<p>References <a class="el" href="classnest_1_1Time.html#a35949d760fe0e0fe43f32a8db86a458f">nest::Time::calibrate()</a>, and <a class="el" href="classnest_1_1Scheduler.html#a7205913a1117826b5c957717334547c5">clock_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a79586ca2064bdb76f77dc5dc356a62a1">nest::Network::calibrate_clock()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3e60a0ad5602cf32c5d53b22764e9e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::clear_pending_spikes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all pending spikes, but do not otherwise manipulate scheduler. </p>
<dl class="section note"><dt>Note</dt><dd>This is used by <a class="el" href="classnest_1_1Network.html#a1a8572993941dd19662ed9383209e9ca" title="Reset the network to the state at T = 0. ">Network::reset_network()</a>. </dd></dl>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a1a8572993941dd19662ed9383209e9ca">nest::Network::reset_network()</a>.</p>

</div>
</div>
<a class="anchor" id="acff16451fe1f6be31b46c2b5de9a5332"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::collocate_buffers_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rearrange the spike_register into a 2-dim structure. </p>
<p>This is done by collecting the spikes from all threads in each slice of the min_delay_ interval. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e05baa2e0c527bfb3888f2cbefcec39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::compute_moduli_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-compute table of fixed modulos, including slice-based. </p>
<p>This function is called after all nodes have been updated.</p>
<p>We can compute the value of (T+d) mod max_delay without explicit reference to the network clock, because compute_moduli_ is called whenever the network clock advances. The various modulos for all available delays are stored in a lookup-table and this table is rotated once per time slice. </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, and <a class="el" href="namespacenest_1_1names.html#ab8c67898fb04b2e13acb81c4d2b5bcdb">nest::names::d</a>.</p>

</div>
</div>
<a class="anchor" id="a77f6d8545e9b67a406e1a8c8bb8db967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::configure_spike_buffers_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize spike_register and comm_buffer to correct dimensions. </p>
<p>Resizes also offgrid_*_buffer_. This is done by <a class="el" href="classnest_1_1Scheduler.html#a2fe1af081c5bbace35baf209d8caead2" title="Resume simulation after an interrupt. ">resume()</a> when called for the first time. The spike buffers cannot be reconfigured later, whence neither the number of local threads or the min_delay can change after <a class="el" href="classnest_1_1Scheduler.html#a36a00f3e4a682ae9e7953f686f2a7e86" title="Simulate for the given time . ">simulate()</a> has been called. ConnectorModel::check_delay() and <a class="el" href="classnest_1_1Scheduler.html#aef5d984bb02ef184bd0817fca5b572be">Scheduler::set_status()</a> ensure this. </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, <a class="el" href="namespacenest_1_1names.html#ac3540cafbc40e90b33f9dae9ee5a70f3">nest::names::clear</a>, <a class="el" href="classnest_1_1Communicator.html#a6c27fa5a846823cc6d3fe8504127db16">nest::Communicator::get_num_processes()</a>, and <a class="el" href="classnest_1_1Communicator.html#a581436bd7343db4bae801d5e06a523ee">nest::Communicator::set_buffer_sizes()</a>.</p>

</div>
</div>
<a class="anchor" id="a334f833f9cbadaca9566337ae8e265da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::create_grng_ </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ctor_call</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>.</p>

</div>
</div>
<a class="anchor" id="addfbb4c585b05dc8af93b22213f12fd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::create_rngs_ </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ctor_call</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>.</p>

</div>
</div>
<a class="anchor" id="a4fe64b26dcbf4e453d57b05f22d2c75e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::deliver_events_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read all event buffers for thread t and send the corresponding Events to the Nodes that are targeted. </p>
<dl class="section note"><dt>Note</dt><dd>It is a crucial property of <a class="el" href="classnest_1_1Scheduler.html#a4fe64b26dcbf4e453d57b05f22d2c75e" title="Read all event buffers for thread t and send the corresponding Events to the Nodes that are targeted...">deliver_events_()</a> that events are delivered ordered by non-decreasing time stamps. BUT: this ordering applies to time stamps only, it does NOT take into account the offsets of precise spikes. </dd></dl>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>.</p>

</div>
</div>
<a class="anchor" id="abd4aca840199490409ffaf0898bda61b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::ensure_valid_thread_local_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that all nodes in the network have valid thread-local IDs. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#afbea3477ba17af320a0974b03add2791">update_nodes_vec_()</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#aedb0f3e65848f396e19ddd32fb7fe630">nest::Network::ensure_valid_thread_local_ids()</a>.</p>

</div>
</div>
<a class="anchor" id="a39db01982170b28bd22dbe2f7ef88565"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::finalize_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize the scheduler by freeing the buffers and destoying the mutexes. </p>

</div>
</div>
<a class="anchor" id="abde400fb8211824aa354ec1aee951b09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::finalize_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke finalize() on nodes registered for finalization. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>.</p>

</div>
</div>
<a class="anchor" id="a85a05f8027a8f1c337f5bbe4ac70aa12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::finalize_simulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup after the simulation. </p>

<p>References <a class="el" href="classnest_1_1Communicator.html#a6c27fa5a846823cc6d3fe8504127db16">nest::Communicator::get_num_processes()</a>, <a class="el" href="classnest_1_1Communicator.html#ab63217ba7e6dfe96df67488a23ad7b50">nest::Communicator::grng_synchrony()</a>, and <a class="el" href="classSLIInterpreter.html#aafcfa7e2b250f23f2c66af03f0fea32e">SLIInterpreter::M_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="af25106abd95c518669e27ebe8e49c555"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::gather_events_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collocate buffers and exchange events with other MPI processes. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>.</p>

</div>
</div>
<a class="anchor" id="acab91a31e7f70b27c9d9250345b1d357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> nest::Scheduler::get_global_thread_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td>
          <td class="paramname"><em>lt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the global thread id of a local thread. </p>

</div>
</div>
<a class="anchor" id="ab5594ab26b725212463c543f76354f56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibrandom.html#a0cb7edb075a0524ec56bb214debecebf">librandom::RngPtr</a> nest::Scheduler::get_grng </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to global random number generator. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#aeb43e28d8e81711289e16e8db278e924">grng_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a8b6be778466abe3308387427453e9ba9">nest::Network::get_grng()</a>.</p>

</div>
</div>
<a class="anchor" id="ad575de8f6e5184376aeea4cc37e73a57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> nest::Scheduler::get_max_delay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return maximal connection delay. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#a91fdc3a261885b5f3d941dc04e81a8fa">max_delay_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Event.html#a85c0a6852059ca005e0365ea2e48763f">nest::Event::get_max_delay()</a>, <a class="el" href="classnest_1_1Network.html#a868d3943b92c5ea6fc4b6817554ce96b">nest::Network::get_max_delay()</a>, <a class="el" href="classnest_1_1RingBuffer.html#a180dd269cf5fbbd9be531222867d711c">nest::RingBuffer::resize()</a>, <a class="el" href="classnest_1_1SliceRingBuffer.html#af995247463e3cf4c1a10446f69c59436">nest::SliceRingBuffer::resize()</a>, <a class="el" href="classnest_1_1MultRBuffer.html#ad3d43fd5d1125f012b4deaca40744c46">nest::MultRBuffer::resize()</a>, and <a class="el" href="classnest_1_1ListRingBuffer.html#a1cad599eada80719aed5f06e7164fd59">nest::ListRingBuffer::resize()</a>.</p>

</div>
</div>
<a class="anchor" id="a69636427b011c4f9526c5247a5697291"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> nest::Scheduler::get_min_delay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return minimal connection delay. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#a6d9d71b493787f129713489a45a7591a">min_delay_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1volume__transmitter.html#afda051d05e0dd70bcdf3786f7d76ab69">nest::volume_transmitter::calibrate()</a>, <a class="el" href="classnest_1_1ListRingBuffer.html#a8515c9520ca713e37a47cfc87e695364">nest::ListRingBuffer::get_list()</a>, <a class="el" href="classnest_1_1Network.html#ad2da57e76562008ab931a84e623a11c6">nest::Network::get_min_delay()</a>, <a class="el" href="classnest_1_1RingBuffer.html#a17007691b22d6546b407cab1dba04472">nest::RingBuffer::get_value()</a>, <a class="el" href="classnest_1_1MultRBuffer.html#a8768b2aa1defe6188aa9b3745775252b">nest::MultRBuffer::get_value()</a>, <a class="el" href="classnest_1_1correlomatrix__detector.html#a398cd55f61ccd8db8f77e09056d3e874">nest::correlomatrix_detector::handle()</a>, <a class="el" href="classnest_1_1RingBuffer.html#a180dd269cf5fbbd9be531222867d711c">nest::RingBuffer::resize()</a>, <a class="el" href="classnest_1_1SliceRingBuffer.html#af995247463e3cf4c1a10446f69c59436">nest::SliceRingBuffer::resize()</a>, <a class="el" href="classnest_1_1MultRBuffer.html#ad3d43fd5d1125f012b4deaca40744c46">nest::MultRBuffer::resize()</a>, <a class="el" href="classnest_1_1ListRingBuffer.html#a1cad599eada80719aed5f06e7164fd59">nest::ListRingBuffer::resize()</a>, <a class="el" href="classnest_1_1binary__neuron.html#a919160db06cc6dc32112bd2f16382ed7">nest::binary_neuron&lt; TGainfunction &gt;::update()</a>, <a class="el" href="classnest_1_1iaf__psc__exp__multisynapse.html#a9fc6b8bed27476b9c613713b7435c9ac">nest::iaf_psc_exp_multisynapse::update()</a>, <a class="el" href="classnest_1_1pulsepacket__generator.html#aebd55943d44ba8df4b05a9cb30cbc3ac">nest::pulsepacket_generator::update()</a>, <a class="el" href="classnest_1_1iaf__psc__alpha__multisynapse.html#a25bf2b2237af05fee8bf8639c51fc7b7">nest::iaf_psc_alpha_multisynapse::update()</a>, <a class="el" href="classnest_1_1poisson__generator__ps.html#a1498af5ca09db8d8e575fac8e04095e7">nest::poisson_generator_ps::update()</a>, <a class="el" href="classnest_1_1gamma__sup__generator.html#af238b917c41f4578f243f477661db051">nest::gamma_sup_generator::update()</a>, <a class="el" href="classnest_1_1parrot__neuron__ps.html#aab884c7a6a36bbee4c4941c5da8be3cc">nest::parrot_neuron_ps::update()</a>, <a class="el" href="classnest_1_1ppd__sup__generator.html#a37fe6aeccb7f6e685fec0169980807f4">nest::ppd_sup_generator::update()</a>, <a class="el" href="classnest_1_1parrot__neuron.html#a7c3f099c154a3283cfb2bc78383ad9cf">nest::parrot_neuron::update()</a>, <a class="el" href="classnest_1_1sinusoidal__poisson__generator.html#a578b22b3ba303e30d816e07e9f6fe72d">nest::sinusoidal_poisson_generator::update()</a>, <a class="el" href="classnest_1_1aeif__cond__alpha__multisynapse.html#a34a1e5305059cdf8f0707470ae221397">nest::aeif_cond_alpha_multisynapse::update()</a>, <a class="el" href="classnest_1_1iaf__chs__2007.html#a5622469780768912616a40d1a6591481">nest::iaf_chs_2007::update()</a>, <a class="el" href="classnest_1_1iaf__cond__exp.html#a9ee0675313e5817ff0d92fb45ae09b92">nest::iaf_cond_exp::update()</a>, <a class="el" href="classnest_1_1poisson__generator.html#a8f4077deb7ea309ea2aa27d12d161159">nest::poisson_generator::update()</a>, <a class="el" href="classnest_1_1izhikevich.html#a348b8f5e124682ae2f3bc003ae84524b">nest::izhikevich::update()</a>, <a class="el" href="classnest_1_1sli__neuron.html#ae3aaf58771b25423de236450cc15974a">nest::sli_neuron::update()</a>, <a class="el" href="classnest_1_1mip__generator.html#aabe5897004c2d2f8c478cb4168b262f9">nest::mip_generator::update()</a>, <a class="el" href="classnest_1_1aeif__cond__alpha__RK5.html#a223c6ecd28e035281ec93202dee5aa8f">nest::aeif_cond_alpha_RK5::update()</a>, <a class="el" href="classnest_1_1volume__transmitter.html#a1fa73fe1886daf284cebdc5fb3c03676">nest::volume_transmitter::update()</a>, <a class="el" href="classnest_1_1iaf__chxk__2008.html#afe6d1855c90576d88c993d71670616bb">nest::iaf_chxk_2008::update()</a>, <a class="el" href="classnest_1_1hh__cond__exp__traub.html#a0475fb745ed6ee841ea0dbdd0fa1c1c8">nest::hh_cond_exp_traub::update()</a>, <a class="el" href="classnest_1_1iaf__cond__exp__sfa__rr.html#a19d2c38414e85903d6b76fda102ec5d3">nest::iaf_cond_exp_sfa_rr::update()</a>, <a class="el" href="classnest_1_1iaf__cond__alpha.html#a674c66f520c5b4816f25fefa102970dd">nest::iaf_cond_alpha::update()</a>, <a class="el" href="classnest_1_1sinusoidal__gamma__generator.html#a758c4b445accfcf3340a76a140035801">nest::sinusoidal_gamma_generator::update()</a>, <a class="el" href="classnest_1_1iaf__psc__exp.html#af0d5aa536053f4f524bc6d61d0b14835">nest::iaf_psc_exp::update()</a>, <a class="el" href="classnest_1_1aeif__cond__alpha.html#a7f6172772dfbd8be81843cc4fd871389">nest::aeif_cond_alpha::update()</a>, <a class="el" href="classnest_1_1iaf__neuron.html#af238c89273dc22f6e31197ebcbd3a07c">nest::iaf_neuron::update()</a>, <a class="el" href="classnest_1_1iaf__psc__delta.html#aac26ec3d8982e26ca59036e994dd88f6">nest::iaf_psc_delta::update()</a>, <a class="el" href="classnest_1_1mat2__psc__exp.html#a458c68fe5cb0105dd9edf4306b1cf6d5">nest::mat2_psc_exp::update()</a>, <a class="el" href="classnest_1_1aeif__cond__exp.html#a27da8ddaba353ffcc534cda6f6b109af">nest::aeif_cond_exp::update()</a>, <a class="el" href="classnest_1_1iaf__psc__alpha.html#a093e2665c82a818c38e19ebffb2a5595">nest::iaf_psc_alpha::update()</a>, <a class="el" href="classnest_1_1iaf__tum__2000.html#a648f5691349bcf1a28e666d27b7a2cd7">nest::iaf_tum_2000::update()</a>, <a class="el" href="classnest_1_1ht__neuron.html#a6396e2fa21a0b252eb3139885cbfda34">nest::ht_neuron::update()</a>, <a class="el" href="classnest_1_1amat2__psc__exp.html#ac8bad992af45d231f32e21f86d99d356">nest::amat2_psc_exp::update()</a>, <a class="el" href="classnest_1_1hh__psc__alpha.html#a5541396c9543288412b1969670582a6c">nest::hh_psc_alpha::update()</a>, <a class="el" href="classnest_1_1pp__psc__delta.html#a9baf323c227628952c1ab7c7899a7f1c">nest::pp_psc_delta::update()</a>, <a class="el" href="classnest_1_1pp__pop__psc__delta.html#a97cc9d40fb51bd4309676d7c446457cf">nest::pp_pop_psc_delta::update()</a>, <a class="el" href="classnest_1_1iaf__cond__alpha__mc.html#aa2d3b9916febd0ba14cef2e038ae11ee">nest::iaf_cond_alpha_mc::update()</a>, <a class="el" href="classnest_1_1iaf__psc__alpha__presc.html#a82dd1dd94b193e04e83e610ad049978e">nest::iaf_psc_alpha_presc::update()</a>, <a class="el" href="classnest_1_1iaf__psc__exp__ps.html#a33e68c966cd851a4df60c3a4926a438c">nest::iaf_psc_exp_ps::update()</a>, <a class="el" href="classnest_1_1iaf__psc__alpha__canon.html#a8dcac6840355a8086d07d67278ebcfee">nest::iaf_psc_alpha_canon::update()</a>, and <a class="el" href="classnest_1_1iaf__psc__delta__canon.html#ac36ab9ae9f0c51d9726ffbc320f23953">nest::iaf_psc_delta_canon::update()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f1d76d40b068c9b0f382aaaa2f0c91e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> nest::Scheduler::get_modulo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return (T+d) mod max_delay. </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, <a class="el" href="namespacenest_1_1names.html#ab8c67898fb04b2e13acb81c4d2b5bcdb">nest::names::d</a>, and <a class="el" href="classnest_1_1Scheduler.html#accbd47c098e40222953ee35705084cf7">moduli_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1RingBuffer.html#a1658b60cc21477c516e90944ba4bf9df">nest::RingBuffer::get_index_()</a>, <a class="el" href="classnest_1_1MultRBuffer.html#a62ef7db814a8bebe409a69c974ead6f0">nest::MultRBuffer::get_index_()</a>, and <a class="el" href="classnest_1_1ListRingBuffer.html#a8047781bf87fbcd20c9d8c1b5d60259b">nest::ListRingBuffer::get_index_()</a>.</p>

</div>
</div>
<a class="anchor" id="a41a7acbcfd0d22d5caad27575137a102"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a> nest::Scheduler::get_n_gsd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get total number of global spike detectors. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#ab8ab7eac504fa5c058b21b16ff06cddd">n_gsd_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a3004efde11ea076e76eff4c894b5449d">nest::Network::add_node()</a>.</p>

</div>
</div>
<a class="anchor" id="a71c271240fe80ca88325da59361ae76a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> nest::Scheduler::get_num_processes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of processes used during simulation. </p>
<p>This functions returns the number of processes. Since each process has the same number of threads, the total number of threads is given by <a class="el" href="classnest_1_1Scheduler.html#a3d76ffe59a674644bad7a5a3f3490a8c" title="Return the number of threads used during simulation. ">get_num_threads()</a>*get_num_processes(). </p>

<p>References <a class="el" href="classnest_1_1Communicator.html#a6c27fa5a846823cc6d3fe8504127db16">nest::Communicator::get_num_processes()</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a733f39ec44b43ad29628a8d07505df11">nest::Network::get_num_processes()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e52f5b1ab7b4435dc6a5d6c2b189f16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> nest::Scheduler::get_num_rec_processes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classnest_1_1Scheduler.html#a4e5d6a6280174d49f81902136bddd4f5">n_rec_procs_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a3004efde11ea076e76eff4c894b5449d">nest::Network::add_node()</a>, and <a class="el" href="classnest_1_1Network.html#a9bf47fdc638c48c92040aed584a929eb">nest::Network::get_num_rec_processes()</a>.</p>

</div>
</div>
<a class="anchor" id="a773c5563d8698e1e5b6cb100bc380672"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> nest::Scheduler::get_num_sim_processes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classnest_1_1Scheduler.html#a0dcb9aed5378181477261e767423c57a">n_sim_procs_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a3004efde11ea076e76eff4c894b5449d">nest::Network::add_node()</a>, and <a class="el" href="classnest_1_1Network.html#aba7f2c1a40abcc0a2421f7f79b84bfb2">nest::Network::get_num_sim_processes()</a>.</p>

</div>
</div>
<a class="anchor" id="a3d76ffe59a674644bad7a5a3f3490a8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> nest::Scheduler::get_num_threads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of threads used during simulation. </p>
<p>This functions returns the number of threads per process. Since each process has the same number of threads, the total number of threads is given by <a class="el" href="classnest_1_1Scheduler.html#a3d76ffe59a674644bad7a5a3f3490a8c" title="Return the number of threads used during simulation. ">get_num_threads()</a>*get_num_processes(). </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#acf172b32fe078d03e9f84417a14d59b9">n_threads_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a9d9964f571d924648463a66c5088c68d">nest::Network::get_num_threads()</a>.</p>

</div>
</div>
<a class="anchor" id="afbcb6daba4b4a0bf6f956b08ae23cbbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nest::Scheduler::get_off_grid_communication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return current communication style. </p>
<p>A result of true means off_grid, false means on_grid communication. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#af6992ac561695c21ed9e5c8945c335c9">off_grid_spiking_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#adbd23aa11f92e4ca23b2597901dbf21c">nest::Network::get_off_grid_communication()</a>.</p>

</div>
</div>
<a class="anchor" id="af69e7c5d2296bf0d49f16019d8e1d9aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnest_1_1Time.html">Time</a> nest::Scheduler::get_previous_slice_origin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classnest_1_1Time.html">Time</a> at beginning of previous slice. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#a7205913a1117826b5c957717334547c5">clock_</a>, <a class="el" href="classnest_1_1Scheduler.html#a6d9d71b493787f129713489a45a7591a">min_delay_</a>, and <a class="el" href="classnest_1_1Time.html#a6d8d183308b48509a8b2ce27361cffed">nest::Time::step</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a14876dcbc3a5de19628d9c5b8ec63757">nest::Network::get_previous_slice_origin()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5355ece7b55a2bebd5c4d20f68b6c0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> nest::Scheduler::get_process_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td>
          <td class="paramname"><em>vp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the process id for a given virtual process. </p>
<p>The real process' id of a virtual process is defined by the relation: p = (vp mod P), where P is the total number of processes. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#a4e5d6a6280174d49f81902136bddd4f5">n_rec_procs_</a>, <a class="el" href="classnest_1_1Scheduler.html#a0dcb9aed5378181477261e767423c57a">n_sim_procs_</a>, and <a class="el" href="classnest_1_1Scheduler.html#acf172b32fe078d03e9f84417a14d59b9">n_threads_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a9c1e97429fdce6ce2485f6d790bf0320">is_local_vp()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cc868750e306521a792603dd3e927f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibrandom.html#a0cb7edb075a0524ec56bb214debecebf">librandom::RngPtr</a> nest::Scheduler::get_rng </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td>
          <td class="paramname"><em>thrd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to random number generator of the specified thread. </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, and <a class="el" href="classnest_1_1Scheduler.html#acde3be9a92d240a2866eb4b8332ecfbd">rng_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#acf4f3837786acea39652b3f853f4bdf4">nest::Network::get_rng()</a>.</p>

</div>
</div>
<a class="anchor" id="aba04d6294b55cd3e28f87f6e5abe27ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nest::Scheduler::get_simulated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true, if the network has already been simulated for some time. </p>
<p>This does NOT indicate that simulate has been called (i.e. if Simulate is called with 0 as argument, the flag is still set to false.) </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#aef73b4dd8cdc93fd70d844796e53fd50">simulated_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a6bd67a3b7ff8d000d4a12331b2f29ffc">nest::Network::get_simulated()</a>, and <a class="el" href="classnest_1_1Network.html#a1a8572993941dd19662ed9383209e9ca">nest::Network::reset_network()</a>.</p>

</div>
</div>
<a class="anchor" id="abc830cf29abc1eda6ac6b3c3d0b32445"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t nest::Scheduler::get_slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get slice number. </p>
<p>Increased by one for each slice. Can be used to choose alternating buffers. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#a86997c3d01d9f2d60b467be498ff4b19">slice_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a7d34d479bedf7c0d6b9c1287078db23d">nest::Network::write_toggle()</a>.</p>

</div>
</div>
<a class="anchor" id="aeab6b144f7579e5507d0386f9bb4f1c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> nest::Scheduler::get_slice_modulo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index to slice-based buffer. </p>
<p>Return ((T+d)/min_delay) % ceil(max_delay/min_delay). </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, <a class="el" href="namespacenest_1_1names.html#ab8c67898fb04b2e13acb81c4d2b5bcdb">nest::names::d</a>, and <a class="el" href="classnest_1_1Scheduler.html#ac9d8621bac8d646f452bdf79fd2b5c33">slice_moduli_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1SliceRingBuffer.html#a57a14a0f314a09e2944780153f692f19">nest::SliceRingBuffer::add_spike()</a>, <a class="el" href="classnest_1_1SliceRingBuffer.html#a01390dbc1eadaab667cfc9918c176818">nest::SliceRingBuffer::discard_events()</a>, and <a class="el" href="classnest_1_1SliceRingBuffer.html#a75765b9d90c31ac2010af3311917d6f0">nest::SliceRingBuffer::prepare_delivery()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c3ae781496ab08b5bd3b3d6aa19bc75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnest_1_1Time.html">Time</a> const &amp; nest::Scheduler::get_slice_origin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classnest_1_1Time.html">Time</a> at beginning of current slice. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#a7205913a1117826b5c957717334547c5">clock_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a7796597085b7a083f835239e5a0ef0eb">nest::Network::get_slice_origin()</a>.</p>

</div>
</div>
<a class="anchor" id="a780633ebfbaf31dca3e4951697de1743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::get_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a90eca40925bf1c5249682361a968cb8c">nest::Network::get_status()</a>, and <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e499ed37893d4f3198493adea8ff69a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnest_1_1Time.html">Time</a> const nest::Scheduler::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Precise time of simulation. </p>
<dl class="section note"><dt>Note</dt><dd>The precise time of the simulation is defined only while the simulation is not in progress. </dd></dl>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, <a class="el" href="classnest_1_1Scheduler.html#a7205913a1117826b5c957717334547c5">clock_</a>, <a class="el" href="classnest_1_1Scheduler.html#a50a538b918c6d2673f9aa12fc6600355">from_step_</a>, <a class="el" href="classnest_1_1Scheduler.html#a2ce1c049d2ce4466ea370a77b02559f3">simulating_</a>, and <a class="el" href="classnest_1_1Time.html#a6d8d183308b48509a8b2ce27361cffed">nest::Time::step</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a7a98e61cb4682d387807a3c6904a1945">nest::Network::get_time()</a>.</p>

</div>
</div>
<a class="anchor" id="af6a7079fdc016a3cc3b33cdb9a262dfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::increment_n_gsd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment total number of global spike detectors by 1. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#ab8ab7eac504fa5c058b21b16ff06cddd">n_gsd_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a3004efde11ea076e76eff4c894b5449d">nest::Network::add_node()</a>.</p>

</div>
</div>
<a class="anchor" id="a53f840c664a675044983325fab047d4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::init_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the scheduler by initializing the buffers. </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, <a class="el" href="classnest_1_1Communicator.html#a6c27fa5a846823cc6d3fe8504127db16">nest::Communicator::get_num_processes()</a>, and <a class="el" href="classSLIInterpreter.html#aafcfa7e2b250f23f2c66af03f0fea32e">SLIInterpreter::M_ERROR</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a6580ac2df0b26a1cb81880bb4d8623b7">Scheduler()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a865a6fdae2053a09becf571631589c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::init_moduli_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, and <a class="el" href="namespacenest_1_1names.html#ab8c67898fb04b2e13acb81c4d2b5bcdb">nest::names::d</a>.</p>

</div>
</div>
<a class="anchor" id="a4363b41b34c9f751c3e000de561c0bc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nest::Scheduler::is_local_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnest_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the node on the local machine, false if not. </p>

<p>References <a class="el" href="classnest_1_1Node.html#a92e0d3bc676fb59d2bf1517f338a8860">nest::Node::get_vp()</a>, and <a class="el" href="classnest_1_1Scheduler.html#a9c1e97429fdce6ce2485f6d790bf0320">is_local_vp()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c1e97429fdce6ce2485f6d790bf0320"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nest::Scheduler::is_local_vp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td>
          <td class="paramname"><em>vp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the thread is on the local machine, false if not. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#ad5355ece7b55a2bebd5c4d20f68b6c0a">get_process_id()</a>, and <a class="el" href="classnest_1_1Communicator.html#ac2dd88a7ae7ec72964103970a36cab4f">nest::Communicator::get_rank()</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a4363b41b34c9f751c3e000de561c0bc7">is_local_node()</a>, and <a class="el" href="classnest_1_1Network.html#a0cc5ec505236ec93d99d88b25e90c6ff">nest::Network::is_local_vp()</a>.</p>

</div>
</div>
<a class="anchor" id="a7430a023de77c7dd90dda0596163315f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::prepare_node_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnest_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialized buffers, register in list of nodes to update/finalize. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611" title="Prepare nodes for simulation and register nodes in node_list. ">prepare_nodes()</a> </dd></dl>

<p>References <a class="el" href="classnest_1_1Node.html#ae13956152ab0cab4d6a3bde2131f11a6">nest::Node::calibrate()</a>, and <a class="el" href="classnest_1_1Node.html#afb55d732ec394229f540f13cacaafbd0">nest::Node::init_buffers()</a>.</p>

</div>
</div>
<a class="anchor" id="a2012a54b09a2754aef94ba533818f611"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::prepare_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare nodes for simulation and register nodes in node_list. </p>
<p>Calls <a class="el" href="classnest_1_1Scheduler.html#a7430a023de77c7dd90dda0596163315f" title="Initialized buffers, register in list of nodes to update/finalize. ">prepare_node_()</a> for each pertaining <a class="el" href="classnest_1_1Node.html" title="Base class for all NEST network objects. ">Node</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classnest_1_1Scheduler.html#a7430a023de77c7dd90dda0596163315f" title="Initialized buffers, register in list of nodes to update/finalize. ">prepare_node_()</a> </dd></dl>

<p>References <a class="el" href="neststartup_8cpp.html#a1fd398483814ea698aacdd87abe755e9">ad</a>, <a class="el" href="classnest_1_1Scheduler.html#a53b3c6274aa230606859cda08ad4153e">advance_time_()</a>, <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, <a class="el" href="classnest_1_1Scheduler.html#acff16451fe1f6be31b46c2b5de9a5332">collocate_buffers_()</a>, <a class="el" href="classnest_1_1Communicator.html#a6c5048b3b9fa6bce8d96512228a1eb82">nest::Communicator::communicate()</a>, <a class="el" href="classnest_1_1Scheduler.html#a334f833f9cbadaca9566337ae8e265da">create_grng_()</a>, <a class="el" href="classlibrandom_1_1RandomGen.html#ab17171e173d0d52d214692adbf055280">librandom::RandomGen::create_knuthlfg_rng()</a>, <a class="el" href="classnest_1_1Scheduler.html#addfbb4c585b05dc8af93b22213f12fd0">create_rngs_()</a>, <a class="el" href="namespacenest_1_1names.html#ab8c67898fb04b2e13acb81c4d2b5bcdb">nest::names::d</a>, <a class="el" href="classlibrandom_1_1RandomGen.html#ab1011e37cc486fe6d555af612229f7cc">librandom::RandomGen::DefaultSeed</a>, <a class="el" href="classnest_1_1Scheduler.html#a4fe64b26dcbf4e453d57b05f22d2c75e">deliver_events_()</a>, <a class="el" href="namespacenumerics.html#acd42d3be907c55f5a5eabeb4c595b976">numerics::e</a>, <a class="el" href="classnest_1_1Node.html#a9f97c6432a9aa151df89653586f72ef1">nest::Node::finalize()</a>, <a class="el" href="classnest_1_1Scheduler.html#abde400fb8211824aa354ec1aee951b09">finalize_nodes()</a>, <a class="el" href="classnest_1_1Scheduler.html#af25106abd95c518669e27ebe8e49c555">gather_events_()</a>, <a class="el" href="classnest_1_1Time.html#a4eb8ea795bb21ff1819eb5c6cb240da5">nest::Time::get_ms()</a>, <a class="el" href="classnest_1_1Time.html#aa51b542808af87407c5708a40f75f26b">nest::Time::get_ms_per_tic()</a>, <a class="el" href="classnest_1_1Communicator.html#a6c27fa5a846823cc6d3fe8504127db16">nest::Communicator::get_num_processes()</a>, <a class="el" href="classnest_1_1Communicator.html#a8c3c11c965cdd88091af23e2f502eca4">nest::Communicator::get_num_virtual_processes()</a>, <a class="el" href="classnest_1_1Communicator.html#a833bbaf61e929df7c0bb6025b6a0b8b5">nest::Communicator::get_recv_buffer_size()</a>, <a class="el" href="classnest_1_1Time.html#a6f14dc87dbd694a028020f00a5a92d7c">nest::Time::get_resolution()</a>, <a class="el" href="classnest_1_1Communicator.html#aeba3a0f96129fef8fe4416fa6379928e">nest::Communicator::get_send_buffer_size()</a>, <a class="el" href="classnest_1_1Scheduler.html#a780633ebfbaf31dca3e4951697de1743">get_status()</a>, <a class="el" href="classnest_1_1Node.html#a2980bee11dfc9f3cf8ef95cef7f29e75">nest::Node::get_thread()</a>, <a class="el" href="classnest_1_1Node.html#aeadd0a40e319cd5a17fe56d6d315f02a">nest::Node::get_thread_sibling_()</a>, <a class="el" href="classnest_1_1Time.html#aaa39806c2ff7a9af66aa26d6f6d6bc4d">nest::Time::get_tics_per_ms()</a>, <a class="el" href="classnest_1_1Time.html#ad66e429cdd2e6a1c234756936d225817">nest::Time::get_tics_per_step()</a>, <a class="el" href="classnest_1_1Communicator.html#a7a8958790fb8e9d49c9dffe52b6fdde9">nest::Communicator::get_use_Allgather()</a>, <a class="el" href="tokenutils_8cc.html#a32eba92c5abb6cb955fad91324b7f076">getValue&lt; long &gt;()</a>, <a class="el" href="classPoorMansAllocator.html#acb0e14bda756a7ee440fd0ab5440da9e">PoorMansAllocator::init()</a>, <a class="el" href="classnest_1_1Node.html#a285524463cdd93a622795fd5b20267fa">nest::Node::is_subnet()</a>, <a class="el" href="classSLIInterpreter.html#aafcfa7e2b250f23f2c66af03f0fea32e">SLIInterpreter::M_ERROR</a>, <a class="el" href="classSLIInterpreter.html#ad07d680a9d59de3d7bad37ad6f43e731">SLIInterpreter::M_INFO</a>, <a class="el" href="classSLIInterpreter.html#aff69c7ddd8b138398cff86e27d04d47b">SLIInterpreter::M_WARNING</a>, <a class="el" href="classnest_1_1Time.html#ae9dee1ca672a6379a3864633c5da2ce9">nest::Time::max()</a>, <a class="el" href="allocator_8h.html#a64b49b1e827c7469fc91de599eabfad1">MAX_THREAD</a>, <a class="el" href="classnest_1_1KernelException.html#ad7e823ac2e6a747cae29fa880cd83470">nest::KernelException::message()</a>, <a class="el" href="classWrappedThreadException.html#a80761d712c907989c94bc79f10086edb">WrappedThreadException::message()</a>, <a class="el" href="classnest_1_1DimensionMismatch.html#a341a59460213f97e07744c944f708b31">nest::DimensionMismatch::message()</a>, <a class="el" href="classnest_1_1Time.html#aaaff952b882c00a4780f337f2742f3ea">nest::Time::min()</a>, <a class="el" href="namespacenest_1_1names.html#aaaa28a9fba4f2e503b794e38f3ea4341">nest::names::n</a>, <a class="el" href="classnest_1_1Node.html#abe4dba47bcd8c788d1be82880190324d">nest::Node::num_thread_siblings_()</a>, <a class="el" href="neststartup_8cpp.html#acec4f97334ca8c98fde9b95e2ecb1642">omp_set_num_threads()</a>, <a class="el" href="classnest_1_1Scheduler.html#a7eb34fd63baadef7f8918dfe854807cb">print_progress_()</a>, <a class="el" href="classnest_1_1Time.html#a6869b5b61a80cd24fb5340ee0484c750">nest::Time::resolution_is_default()</a>, <a class="el" href="randomtest_8cpp.html#ac9d4941e645299a70fafceb3b1f85218">seed</a>, <a class="el" href="classnest_1_1Scheduler.html#a5d7d1d094655d23590cb6458224e0f3d">set_num_rec_processes()</a>, <a class="el" href="classnest_1_1Scheduler.html#ab191f093886075861ce4ff1fbd41870e">set_num_threads()</a>, <a class="el" href="classnest_1_1Communicator.html#a3efdf29675234c117984abbe6c362c33">nest::Communicator::set_num_threads()</a>, <a class="el" href="classnest_1_1Event.html#aed6e78df631820dec81bec883a122e53">nest::Event::set_offset()</a>, <a class="el" href="classnest_1_1Time.html#a79e576f1e74cd6247ceac5ae4c893f60">nest::Time::set_resolution()</a>, <a class="el" href="classnest_1_1Event.html#a1769d6830e104b6221cfcb61edce6277">nest::Event::set_sender_gid()</a>, <a class="el" href="classnest_1_1Event.html#a47c5bdb5473b5b8971b2a077aec754e0">nest::Event::set_stamp()</a>, <a class="el" href="classnest_1_1Scheduler.html#aef5d984bb02ef184bd0817fca5b572be">set_status()</a>, <a class="el" href="classnest_1_1Node.html#ad6b1c6a7b2287c55a982debe99e66415">nest::Node::set_thread_lid()</a>, <a class="el" href="classnest_1_1TimeModifier.html#ae980ddf77e90ac490f2a88b350f171cf">nest::TimeModifier::set_time_representation()</a>, <a class="el" href="classnest_1_1Communicator.html#a151e870130e6cf3f4cc6b5c84c8116da">nest::Communicator::set_use_Allgather()</a>, <a class="el" href="classTokenArray.html#a6c6bc0f874087b5fee6a91ed345ab541">TokenArray::size()</a>, <a class="el" href="classnest_1_1Time.html#a6d8d183308b48509a8b2ce27361cffed">nest::Time::step</a>, <a class="el" href="namespacenest.html#a0f3b2839c35955d06d818b569e290f8d">nest::TimeZero</a>, <a class="el" href="classnest_1_1Scheduler.html#afbea3477ba17af320a0974b03add2791">update_nodes_vec_()</a>, and <a class="el" href="namespacenest_1_1names.html#af06cbfcfb628623779c3e1d418634a35">nest::names::vp</a>.</p>

</div>
</div>
<a class="anchor" id="a0667834bfe78b86bbcad103a9bdb1d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::prepare_simulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All steps that must be done before a simulation. </p>

<p>References <a class="el" href="classnest_1_1Communicator.html#af21f91e4f3a34b279e7a7dcb718f8c76">nest::Communicator::enter_runtime()</a>, <a class="el" href="classnest_1_1Time.html#a4eb8ea795bb21ff1819eb5c6cb240da5">nest::Time::get_ms()</a>, <a class="el" href="classnest_1_1Communicator.html#a6c27fa5a846823cc6d3fe8504127db16">nest::Communicator::get_num_processes()</a>, <a class="el" href="classnest_1_1Time.html#a6f14dc87dbd694a028020f00a5a92d7c">nest::Time::get_resolution()</a>, <a class="el" href="classnest_1_1Communicator.html#ab63217ba7e6dfe96df67488a23ad7b50">nest::Communicator::grng_synchrony()</a>, <a class="el" href="classSLIInterpreter.html#aafcfa7e2b250f23f2c66af03f0fea32e">SLIInterpreter::M_ERROR</a>, and <a class="el" href="classSLIInterpreter.html#ad07d680a9d59de3d7bad37ad6f43e731">SLIInterpreter::M_INFO</a>.</p>

</div>
</div>
<a class="anchor" id="a7eb34fd63baadef7f8918dfe854807cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::print_progress_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>.</p>

</div>
</div>
<a class="anchor" id="af4535609ec782a4197cfd8f9e82c81ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bring scheduler back to its initial state. </p>
<dl class="section note"><dt>Note</dt><dd>Threading parameters as well as random number state are not reset. This has to be done manually. </dd></dl>

<p>References <a class="el" href="classnest_1_1TimeModifier.html#a47e9ae133988bee8b9c48a7507dc93d5">nest::TimeModifier::reset_to_defaults()</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#ae9a3dccfd528ad0d274a9ef3341a9347">nest::Network::reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a2fe1af081c5bbace35baf209d8caead2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume simulation after an interrupt. </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, <a class="el" href="classSLIInterpreter.html#aafcfa7e2b250f23f2c66af03f0fea32e">SLIInterpreter::M_ERROR</a>, <a class="el" href="classSLIInterpreter.html#ad07d680a9d59de3d7bad37ad6f43e731">SLIInterpreter::M_INFO</a>, <a class="el" href="scheduler_8cpp.html#a2be3be3de0ff346e1fcca17b012c5184">SLIsignalflag</a>, <a class="el" href="classnest_1_1Communicator.html#a44486415802c03605c6779587df545fc">nest::Communicator::synchronize()</a>, and <a class="el" href="namespacenest_1_1names.html#a9087fe6389d17ca6b28f0fb617b6f605">nest::names::update</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#af775b26b0deb68561541d8da8742f485">nest::Network::resume()</a>.</p>

</div>
</div>
<a class="anchor" id="a79a63fa3f4e64ad9d8dc2ba38c64ec4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::send_offgrid_remote </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnest_1_1SpikeEvent.html">SpikeEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenest.html#a042890c99221c8143a36ca44fea0f8f8">long_t</a>&#160;</td>
          <td class="paramname"><em>lag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add global id of event sender to the spike_register. </p>
<p>Store event offset with global id. An event sent through this method will remain in the queue until the network time has advanced by min_delay_ steps. After this period the buffers are collocated and sent to the partner machines.</p>
<p>Old documentation from <a class="el" href="network_8h.html" title="Declarations for class Network. ">network.h</a>: Place an event in the global event queue. Add event to the queue to be delivered when it is due. At the delivery time, the target list of the sender is iterated and the event is delivered to all targets. The event is guaranteed to arrive at the receiver when all elements are updated and the system is in a synchronised (single threaded) state. </p><dl class="section see"><dt>See also</dt><dd>send_to_targets() </dd></dl>

<p>References <a class="el" href="classnest_1_1Node.html#aeecd18909e52d343608447484e6992cf">nest::Node::get_gid()</a>, <a class="el" href="classnest_1_1SpikeEvent.html#a5273b478ed5c5aa3a0e6a1e2e46d943a">nest::SpikeEvent::get_multiplicity()</a>, <a class="el" href="classnest_1_1Event.html#a0e1473d13168803685905c80a0ff924a">nest::Event::get_offset()</a>, <a class="el" href="classnest_1_1Event.html#ad97fa49dad1630e9fe53db9efcfffc6f">nest::Event::get_sender()</a>, <a class="el" href="classnest_1_1Scheduler.html#adf398119a87288e7378158de10f473bc">offgrid_spike_register_</a>, and <a class="el" href="neststartup_8cpp.html#a39d5bb36624dd92bd437407e6043224f">push_back()</a>.</p>

</div>
</div>
<a class="anchor" id="a339e5109da9de77cbfde2a78787ad8bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::send_remote </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnest_1_1SpikeEvent.html">SpikeEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenest.html#a042890c99221c8143a36ca44fea0f8f8">long_t</a>&#160;</td>
          <td class="paramname"><em>lag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add global id of event sender to the spike_register. </p>
<p>An event sent through this method will remain in the queue until the network time has advanced by min_delay_ steps. After this period the buffers are collocated and sent to the partner machines.</p>
<p>Old documentation from <a class="el" href="network_8h.html" title="Declarations for class Network. ">network.h</a>: Place an event in the global event queue. Add event to the queue to be delivered when it is due. At the delivery time, the target list of the sender is iterated and the event is delivered to all targets. The event is guaranteed to arrive at the receiver when all elements are updated and the system is in a synchronised (single threaded) state. </p><dl class="section see"><dt>See also</dt><dd>send_to_targets() </dd></dl>

<p>References <a class="el" href="classnest_1_1Node.html#aeecd18909e52d343608447484e6992cf">nest::Node::get_gid()</a>, <a class="el" href="classnest_1_1SpikeEvent.html#a5273b478ed5c5aa3a0e6a1e2e46d943a">nest::SpikeEvent::get_multiplicity()</a>, <a class="el" href="classnest_1_1Event.html#ad97fa49dad1630e9fe53db9efcfffc6f">nest::Event::get_sender()</a>, <a class="el" href="neststartup_8cpp.html#a39d5bb36624dd92bd437407e6043224f">push_back()</a>, and <a class="el" href="classnest_1_1Scheduler.html#a3df87f171d097e16a64ab3ad8c55993d">spike_register_</a>.</p>

</div>
</div>
<a class="anchor" id="a5e52e4f10ae9215bd1f192ec42080be7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::set_network_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnest_1_1Network.html">Network</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d7d1d094655d23590cb6458224e0f3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::set_num_rec_processes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>called_by_reset</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set number of recording processes, switches NEST to global spike detection mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nrp</td><td>number of recording processes </td></tr>
    <tr><td class="paramname">called_by_reset</td><td>pass true when calling from <a class="el" href="classnest_1_1Scheduler.html#af4535609ec782a4197cfd8f9e82c81ed" title="Bring scheduler back to its initial state. ">Scheduler::reset()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>called_by_reset</code> parameter is a cludge to avoid a chicken-and-egg problem when resetting the kernel. It surpresses a test for existing nodes, trusting that the kernel will immediately afterwards delete all existing nodes. </dd></dl>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>, <a class="el" href="classnest_1_1Network.html#a9b3c4cb8676cc968ae2fc1735ba17559">nest::Network::reset_kernel()</a>, and <a class="el" href="classnest_1_1Network.html#aa47c826c222dd6072709c904693a96c2">nest::Network::set_num_rec_processes()</a>.</p>

</div>
</div>
<a class="anchor" id="ab191f093886075861ce4ff1fbd41870e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::set_num_threads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td>
          <td class="paramname"><em>n_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of threads by setting the internal variable n_threads_, the corresponding value in the <a class="el" href="classnest_1_1Communicator.html">Communicator</a>, and the OpenMP number of threads. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>, and <a class="el" href="classnest_1_1Network.html#a9b3c4cb8676cc968ae2fc1735ba17559">nest::Network::reset_kernel()</a>.</p>

</div>
</div>
<a class="anchor" id="a2154aa76e166b576b67b034a10587a31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::set_off_grid_communication </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>off_grid_spiking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set communication style to off_grid (true) or on_grid </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#af6992ac561695c21ed9e5c8945c335c9">off_grid_spiking_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a3004efde11ea076e76eff4c894b5449d">nest::Network::add_node()</a>.</p>

</div>
</div>
<a class="anchor" id="aef5d984bb02ef184bd0817fca5b572be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::set_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>, and <a class="el" href="classnest_1_1Network.html#a3b6a303dfd1c84cfa8cfad16b5da0fc0">nest::Network::set_status()</a>.</p>

</div>
</div>
<a class="anchor" id="a36a00f3e4a682ae9e7953f686f2a7e86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::simulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnest_1_1Time.html">Time</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate for the given time . </p>
<p>This function performs the following steps</p><ol type="1">
<li>set the new simulation time</li>
<li>call <a class="el" href="classnest_1_1Scheduler.html#a0667834bfe78b86bbcad103a9bdb1d40" title="All steps that must be done before a simulation. ">prepare_simulation()</a></li>
<li>call <a class="el" href="classnest_1_1Scheduler.html#a2fe1af081c5bbace35baf209d8caead2" title="Resume simulation after an interrupt. ">resume()</a></li>
<li>call <a class="el" href="classnest_1_1Scheduler.html#a85a05f8027a8f1c337f5bbe4ac70aa12" title="Cleanup after the simulation. ">finalize_simulation()</a> </li>
</ol>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, <a class="el" href="classnest_1_1Time.html#a6f14dc87dbd694a028020f00a5a92d7c">nest::Time::get_resolution()</a>, <a class="el" href="classnest_1_1Time.html#aee8f8bd8d0971f7fb8a07bbef1b45599">nest::Time::get_steps()</a>, <a class="el" href="classnest_1_1Time.html#adfcd7d21031a0f4a7aa52d852d820ad8">nest::Time::is_finite()</a>, <a class="el" href="classSLIInterpreter.html#aafcfa7e2b250f23f2c66af03f0fea32e">SLIInterpreter::M_ERROR</a>, <a class="el" href="classSLIInterpreter.html#aff69c7ddd8b138398cff86e27d04d47b">SLIInterpreter::M_WARNING</a>, and <a class="el" href="classnest_1_1Time.html#ae9dee1ca672a6379a3864633c5da2ce9">nest::Time::max()</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a61433721eaf81a90ccd796a84e3dc7b3">nest::Network::simulate()</a>.</p>

</div>
</div>
<a class="anchor" id="acb5f137ca1a086183e294f8f93fdfed4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> nest::Scheduler::suggest_rec_vp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a>&#160;</td>
          <td class="paramname"><em>gid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a thread number for a given global recording node id. </p>
<p>Each node has a default thread on which it will run. The thread is defined by the relation: t = (gid div P) mod T, where P is the number of recording processes and T the number of threads. This may be used by network::add_node() if the user has not specified anything. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#a4e5d6a6280174d49f81902136bddd4f5">n_rec_procs_</a>, <a class="el" href="classnest_1_1Scheduler.html#a0dcb9aed5378181477261e767423c57a">n_sim_procs_</a>, and <a class="el" href="classnest_1_1Scheduler.html#acf172b32fe078d03e9f84417a14d59b9">n_threads_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a356b3de030230d3e568277c9d06a4a93">nest::Network::suggest_rec_vp()</a>.</p>

</div>
</div>
<a class="anchor" id="a15767831fa857d512e6ffd2f5a36e8a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> nest::Scheduler::suggest_vp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a>&#160;</td>
          <td class="paramname"><em>gid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a thread number for a given global node id. </p>
<p>Each node has a default thread on which it will run. The thread is defined by the relation: t = (gid div P) mod T, where P is the number of simulation processes and T the number of threads. This may be used by network::add_node() if the user has not specified anything. </p>

<p>References <a class="el" href="classnest_1_1Scheduler.html#a0dcb9aed5378181477261e767423c57a">n_sim_procs_</a>, and <a class="el" href="classnest_1_1Scheduler.html#acf172b32fe078d03e9f84417a14d59b9">n_threads_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#a44ad8436f360f874e3033453ba054bfb">nest::Network::suggest_vp()</a>.</p>

</div>
</div>
<a class="anchor" id="ac61af144516a230948e193bd492b56e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::terminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classnest_1_1Scheduler.html#a2532a56cee80e3532d9263cb8062b0d1">terminate_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#ab5a9bc4e2ddc649830dca3741fd23614">nest::Network::execute_sli_protected()</a>, and <a class="el" href="classnest_1_1Network.html#a03a40d54658f0dba41ad92383a643b22">nest::Network::terminate()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d7da977c215808e0b733e2cf7f9fd5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnest_1_1Node.html">Node</a> * nest::Scheduler::thread_lid_to_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenest.html#adad102550a6102c0c0bea1d1083a233f">targetindex</a>&#160;</td>
          <td class="paramname"><em>thread_local_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classnest_1_1Scheduler.html#ab7e4343087b672ab65880931a4a63b40">nodes_vec_</a>, and <a class="el" href="namespacenest_1_1names.html#ab31071241bc6849b0ab124df4f54e429">nest::names::thread_local_id</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#aa013c077a5fd855b52d9ecbaf423b30a">nest::Network::thread_lid_to_node()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1c27ab18ac3c210e7b482b8bde0dc1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> nest::Scheduler::thread_to_vp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classnest_1_1Communicator.html#ac2dd88a7ae7ec72964103970a36cab4f">nest::Communicator::get_rank()</a>, <a class="el" href="classnest_1_1Scheduler.html#a4e5d6a6280174d49f81902136bddd4f5">n_rec_procs_</a>, <a class="el" href="classnest_1_1Scheduler.html#a0dcb9aed5378181477261e767423c57a">n_sim_procs_</a>, and <a class="el" href="classnest_1_1Scheduler.html#acf172b32fe078d03e9f84417a14d59b9">n_threads_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#adf5b54bcecebb8d846638d78017ee688">nest::Network::thread_to_vp()</a>.</p>

</div>
</div>
<a class="anchor" id="ab60d36339f1f8b20722f362ee3159873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update all non-frozen nodes. </p>
<p>This function uses OpenMP for multi-threading if enabled at configure time and runs with a single thread otherwise. </p>

<p>References <a class="el" href="classnest_1_1Communicator.html#af6f0dd54e81032005e302f99ec88d560">nest::Communicator::advance_music_time()</a>, <a class="el" href="namespacenumerics.html#acd42d3be907c55f5a5eabeb4c595b976">numerics::e</a>, <a class="el" href="classSLIInterpreter.html#ad07d680a9d59de3d7bad37ad6f43e731">SLIInterpreter::M_INFO</a>, and <a class="el" href="scheduler_8cpp.html#a2be3be3de0ff346e1fcca17b012c5184">SLIsignalflag</a>.</p>

</div>
</div>
<a class="anchor" id="a3cc8d4b2402923099701cd2fa267be43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::update_delay_extrema_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update delay extrema to current values. </p>
<p>Static since it only operates in static variables. This allows it to be called from const-method <a class="el" href="classnest_1_1Scheduler.html#a780633ebfbaf31dca3e4951697de1743">get_status()</a> as well. </p>

<p>References <a class="el" href="classnest_1_1Communicator.html#a6c5048b3b9fa6bce8d96512228a1eb82">nest::Communicator::communicate()</a>, <a class="el" href="classnest_1_1Communicator.html#a6c27fa5a846823cc6d3fe8504127db16">nest::Communicator::get_num_processes()</a>, <a class="el" href="classnest_1_1Communicator.html#ac2dd88a7ae7ec72964103970a36cab4f">nest::Communicator::get_rank()</a>, <a class="el" href="classnest_1_1Time.html#a6f14dc87dbd694a028020f00a5a92d7c">nest::Time::get_resolution()</a>, <a class="el" href="classnest_1_1Time.html#aee8f8bd8d0971f7fb8a07bbef1b45599">nest::Time::get_steps()</a>, and <a class="el" href="classnest_1_1Time.html#acb1c377c4d654c34797f9fef4c02250a">nest::Time::pos_inf()</a>.</p>

</div>
</div>
<a class="anchor" id="afbea3477ba17af320a0974b03add2791"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nest::Scheduler::update_nodes_vec_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create up-to-date vector of local nodes, nodes_vec_. </p>
<p>This method also sets the thread-local ID on all local nodes. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#abd4aca840199490409ffaf0898bda61b">ensure_valid_thread_local_ids()</a>, and <a class="el" href="classnest_1_1Scheduler.html#a2012a54b09a2754aef94ba533818f611">prepare_nodes()</a>.</p>

</div>
</div>
<a class="anchor" id="a73766c296b7a760ccd42a30a9faaeb56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a> nest::Scheduler::vp_to_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenest.html#acb17d7e435753e90c938e010c8e3adcc">thread</a>&#160;</td>
          <td class="paramname"><em>vp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classnest_1_1Communicator.html#ac2dd88a7ae7ec72964103970a36cab4f">nest::Communicator::get_rank()</a>, <a class="el" href="classnest_1_1Scheduler.html#a4e5d6a6280174d49f81902136bddd4f5">n_rec_procs_</a>, <a class="el" href="classnest_1_1Scheduler.html#a0dcb9aed5378181477261e767423c57a">n_sim_procs_</a>, and <a class="el" href="classnest_1_1Scheduler.html#acf172b32fe078d03e9f84417a14d59b9">n_threads_</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Network.html#ad47eca4f7210bedeb7a84a55802a2812">nest::Network::vp_to_thread()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7205913a1117826b5c957717334547c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnest_1_1Time.html">Time</a> nest::Scheduler::clock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classnest_1_1Network.html" title="Main administrative interface to the network. ">Network</a> clock, updated once per slice. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a9faa23ac781ba9c16ee3c1f61fe96b93">calibrate_clock()</a>, <a class="el" href="classnest_1_1Scheduler.html#af69e7c5d2296bf0d49f16019d8e1d9aa">get_previous_slice_origin()</a>, <a class="el" href="classnest_1_1Scheduler.html#a4c3ae781496ab08b5bd3b3d6aa19bc75">get_slice_origin()</a>, and <a class="el" href="classnest_1_1Scheduler.html#a8e499ed37893d4f3198493adea8ff69a">get_time()</a>.</p>

</div>
</div>
<a class="anchor" id="a573adb8c9ee29ed17d65d7bb9809f35d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">nest::delay</a> nest::Scheduler::comm_marker_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marker Value to be put between the data fields from different time steps during communication. </p>

</div>
</div>
<a class="anchor" id="a3e11627ff95327c6aa64397feff26b79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; nest::Scheduler::displacements_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer containing the starting positions for the spikes from each process within the global_(off)grid_spikes_ buffer. </p>

</div>
</div>
<a class="anchor" id="afcfdcf14299bc184df4610925b4dce2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a> nest::Scheduler::entry_counter_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter for entry barrier. </p>

</div>
</div>
<a class="anchor" id="ac9cb3fe86624b46340cff9387ca263f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a> nest::Scheduler::exit_counter_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter for exit barrier. </p>

</div>
</div>
<a class="anchor" id="a8774dfba36b5ffd36a4fc538c9b74bad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nest::Scheduler::force_singlethreading_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a50a538b918c6d2673f9aa12fc6600355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> nest::Scheduler::from_step_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update clock_+from_step&lt;=T&lt;clock_+to_step_ </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a8e499ed37893d4f3198493adea8ff69a">get_time()</a>.</p>

</div>
</div>
<a class="anchor" id="a2984af6a16d22178da3b91b467312ed8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacenest.html#af3860d4cd9794a72414678987b1cfcc8">uint_t</a>&gt; nest::Scheduler::global_grid_spikes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer containing the gids of all neurons that spiked in the last min_delay_ interval. </p>
<p>The single slices are separated by a marker value </p>

</div>
</div>
<a class="anchor" id="ac00226cd82de9f0fe7e5c2576421aa13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacenest.html#a9ffcbdfc4ad79fd1bea02f80d34c99fe">OffGridSpike</a>&gt; nest::Scheduler::global_offgrid_spikes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer containing the gids and offsets for all neurons that fired off-grid spikes in the last min_delay_ interval. </p>
<p>The single slices are separated by a marker value. </p>

</div>
</div>
<a class="anchor" id="aeb43e28d8e81711289e16e8db278e924"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibrandom.html#a0cb7edb075a0524ec56bb214debecebf">librandom::RngPtr</a> nest::Scheduler::grng_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global random number generator. </p>
<p>This rng must be synchronized on all threads </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#ab5594ab26b725212463c543f76354f56">get_grng()</a>.</p>

</div>
</div>
<a class="anchor" id="a20ba6d5c2dd71883933b8a8b7a5d7a06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a042890c99221c8143a36ca44fea0f8f8">long_t</a> nest::Scheduler::grng_seed_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The seed of the global RNG, not neccessarily describing the state of the GRNG. </p>

</div>
</div>
<a class="anchor" id="a73ea61977eac1e8bc6e62ae62734b4e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nest::Scheduler::initialized_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afb59504ceab10064539890b324ae1395"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacenest.html#af3860d4cd9794a72414678987b1cfcc8">uint_t</a>&gt; nest::Scheduler::local_grid_spikes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer containing the gids of local neurons that spiked in the last min_delay_ interval. </p>
<p>The single slices are separated by a marker value. </p>

</div>
</div>
<a class="anchor" id="adacd816ad60eb43bfbe5a135979de678"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacenest.html#a9ffcbdfc4ad79fd1bea02f80d34c99fe">OffGridSpike</a>&gt; nest::Scheduler::local_offgrid_spikes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer containing the gids and offsets for local neurons that fired off-grid spikes in the last min_delay_ interval. </p>
<p>The single slices are separated by a marker value. </p>

</div>
</div>
<a class="anchor" id="a91fdc3a261885b5f3d941dc04e81a8fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">nest::delay</a> nest::Scheduler::max_delay_ = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value of the largest delay in the network. </p>
<p>Static because <a class="el" href="classnest_1_1Scheduler.html#ad575de8f6e5184376aeea4cc37e73a57" title="Return maximal connection delay. ">get_max_delay()</a> must be static to allow access from neuron models. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#ad575de8f6e5184376aeea4cc37e73a57">get_max_delay()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d9d71b493787f129713489a45a7591a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">nest::delay</a> nest::Scheduler::min_delay_ = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value of the smallest delay in the network. </p>
<p>Static because <a class="el" href="classnest_1_1Scheduler.html#a69636427b011c4f9526c5247a5697291" title="Return minimal connection delay. ">get_min_delay()</a> must be static to allow access from neuron models. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a69636427b011c4f9526c5247a5697291">get_min_delay()</a>, and <a class="el" href="classnest_1_1Scheduler.html#af69e7c5d2296bf0d49f16019d8e1d9aa">get_previous_slice_origin()</a>.</p>

</div>
</div>
<a class="anchor" id="accbd47c098e40222953ee35705084cf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">nest::delay</a> &gt; nest::Scheduler::moduli_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table of pre-computed modulos. </p>
<p>This table is used to map time steps, given as offset from now, to ring-buffer bins. There are min_delay+max_delay bins in a ring buffer, and the moduli_ array is rotated by min_delay elements after each slice is completed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classnest_1_1RingBuffer.html" title="Buffer Layout. ">RingBuffer</a> </dd></dl>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a6f1d76d40b068c9b0f382aaaa2f0c91e">get_modulo()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8ab7eac504fa5c058b21b16ff06cddd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a> nest::Scheduler::n_gsd_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of global spike detectors, used for distributing them over recording processes. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a41a7acbcfd0d22d5caad27575137a102">get_n_gsd()</a>, and <a class="el" href="classnest_1_1Scheduler.html#af6a7079fdc016a3cc3b33cdb9a262dfa">increment_n_gsd()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e5d6a6280174d49f81902136bddd4f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a> nest::Scheduler::n_rec_procs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MPI processes dedicated for recording devices. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a6e52f5b1ab7b4435dc6a5d6c2b189f16">get_num_rec_processes()</a>, <a class="el" href="classnest_1_1Scheduler.html#ad5355ece7b55a2bebd5c4d20f68b6c0a">get_process_id()</a>, <a class="el" href="classnest_1_1Scheduler.html#acb5f137ca1a086183e294f8f93fdfed4">suggest_rec_vp()</a>, <a class="el" href="classnest_1_1Scheduler.html#ac1c27ab18ac3c210e7b482b8bde0dc1d">thread_to_vp()</a>, and <a class="el" href="classnest_1_1Scheduler.html#a73766c296b7a760ccd42a30a9faaeb56">vp_to_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="a0dcb9aed5378181477261e767423c57a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a> nest::Scheduler::n_sim_procs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MPI processes used for simulation. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a773c5563d8698e1e5b6cb100bc380672">get_num_sim_processes()</a>, <a class="el" href="classnest_1_1Scheduler.html#ad5355ece7b55a2bebd5c4d20f68b6c0a">get_process_id()</a>, <a class="el" href="classnest_1_1Scheduler.html#acb5f137ca1a086183e294f8f93fdfed4">suggest_rec_vp()</a>, <a class="el" href="classnest_1_1Scheduler.html#a15767831fa857d512e6ffd2f5a36e8a1">suggest_vp()</a>, <a class="el" href="classnest_1_1Scheduler.html#ac1c27ab18ac3c210e7b482b8bde0dc1d">thread_to_vp()</a>, and <a class="el" href="classnest_1_1Scheduler.html#a73766c296b7a760ccd42a30a9faaeb56">vp_to_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="acf172b32fe078d03e9f84417a14d59b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a> nest::Scheduler::n_threads_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of threads per process. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a3d76ffe59a674644bad7a5a3f3490a8c">get_num_threads()</a>, <a class="el" href="classnest_1_1Scheduler.html#ad5355ece7b55a2bebd5c4d20f68b6c0a">get_process_id()</a>, <a class="el" href="classnest_1_1Scheduler.html#acb5f137ca1a086183e294f8f93fdfed4">suggest_rec_vp()</a>, <a class="el" href="classnest_1_1Scheduler.html#a15767831fa857d512e6ffd2f5a36e8a1">suggest_vp()</a>, <a class="el" href="classnest_1_1Scheduler.html#ac1c27ab18ac3c210e7b482b8bde0dc1d">thread_to_vp()</a>, and <a class="el" href="classnest_1_1Scheduler.html#a73766c296b7a760ccd42a30a9faaeb56">vp_to_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e7e39b5342371664746e20ad56f1973"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnest_1_1Network.html">nest::Network</a> * nest::Scheduler::net_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to network object. </p>
<p>Maintained as a static pointer so that <a class="el" href="classnest_1_1Scheduler.html#a3cc8d4b2402923099701cd2fa267be43" title="Update delay extrema to current values. ">update_delay_extrema_()</a> can be a static function and update thet static min/max_delay_ variables even from get_status() const. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a6580ac2df0b26a1cb81880bb4d8623b7">Scheduler()</a>.</p>

</div>
</div>
<a class="anchor" id="ab7e4343087b672ab65880931a4a63b40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;<a class="el" href="classnest_1_1Node.html">Node</a>*&gt; &gt; nest::Scheduler::nodes_vec_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nodelists for nodes for each thread. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a7d7da977c215808e0b733e2cf7f9fd5e">thread_lid_to_node()</a>.</p>

</div>
</div>
<a class="anchor" id="a744beca957a26904f88f2d0fa8a77d9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a48ce49a10a37dfb7f5243583ff1d4b85">index</a> nest::Scheduler::nodes_vec_network_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classnest_1_1Network.html" title="Main administrative interface to the network. ">Network</a> size when nodes_vec_ was last updated. </p>

</div>
</div>
<a class="anchor" id="af6992ac561695c21ed9e5c8945c335c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nest::Scheduler::off_grid_spiking_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicates whether spikes are not constrained to the grid </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#afbcb6daba4b4a0bf6f956b08ae23cbbd">get_off_grid_communication()</a>, and <a class="el" href="classnest_1_1Scheduler.html#a2154aa76e166b576b67b034a10587a31">set_off_grid_communication()</a>.</p>

</div>
</div>
<a class="anchor" id="adf398119a87288e7378158de10f473bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;<a class="el" href="namespacenest.html#a9ffcbdfc4ad79fd1bea02f80d34c99fe">OffGridSpike</a>&gt; &gt; &gt; nest::Scheduler::offgrid_spike_register_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register for off-grid spikes. </p>
<p>This is a 3-dim structure.</p><ul>
<li>First dim: Each thread has its own vector to write to.</li>
<li>Second dim: A vector for each slice of the min_delay interval</li>
<li>Third dim: Struct containing GID and offset. </li>
</ul>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a79a63fa3f4e64ad9d8dc2ba38c64ec4a">send_offgrid_remote()</a>.</p>

</div>
</div>
<a class="anchor" id="a175e773656e38507c7eb7d941394989d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nest::Scheduler::print_time_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether time should be printed during simulations (or not) </p>

</div>
</div>
<a class="anchor" id="acde3be9a92d240a2866eb4b8332ecfbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="namespacelibrandom.html#a0cb7edb075a0524ec56bb214debecebf">librandom::RngPtr</a>&gt; nest::Scheduler::rng_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of random number generators for threads. </p>
<p>There must be PRECISELY one rng per thread. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a5cc868750e306521a792603dd3e927f5">get_rng()</a>.</p>

</div>
</div>
<a class="anchor" id="a3d932367532ab0af064426d44db3c31e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacenest.html#a042890c99221c8143a36ca44fea0f8f8">long_t</a>&gt; nest::Scheduler::rng_seeds_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The seeds of the local RNGs. These do not neccessarily describe the state of the RNGs. </p>

</div>
</div>
<a class="anchor" id="aef73b4dd8cdc93fd70d844796e53fd50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nest::Scheduler::simulated_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicates whether the network has already been simulated for some time </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#aba04d6294b55cd3e28f87f6e5abe27ab">get_simulated()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ce1c049d2ce4466ea370a77b02559f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nest::Scheduler::simulating_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if simulation in progress </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a8e499ed37893d4f3198493adea8ff69a">get_time()</a>.</p>

</div>
</div>
<a class="anchor" id="a86997c3d01d9f2d60b467be498ff4b19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> nest::Scheduler::slice_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>current update slice </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#abc830cf29abc1eda6ac6b3c3d0b32445">get_slice()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9d8621bac8d646f452bdf79fd2b5c33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">nest::delay</a> &gt; nest::Scheduler::slice_moduli_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table of pre-computed slice-based modulos. </p>
<p>This table is used to map time steps, give as offset from now, to slice-based ring-buffer bins. There are ceil(max_delay/min_delay) bins in a slice-based ring buffer, one per slice within max_delay. Since max_delay may not be a multiple of min_delay, we cannot simply rotate the table content after each slice, but have to recompute the table anew. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classnest_1_1SliceRingBuffer.html" title="Queue for all spikes arriving into a neuron. ">SliceRingBuffer</a> </dd></dl>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#aeab6b144f7579e5507d0386f9bb4f1c6">get_slice_modulo()</a>.</p>

</div>
</div>
<a class="anchor" id="a3df87f171d097e16a64ab3ad8c55993d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;<a class="el" href="namespacenest.html#af3860d4cd9794a72414678987b1cfcc8">uint_t</a>&gt; &gt; &gt; nest::Scheduler::spike_register_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register for gids of neurons that spiked. </p>
<p>This is a 3-dim structure.</p><ul>
<li>First dim: Each thread has its own vector to write to.</li>
<li>Second dim: A vector for each slice of the min_delay interval</li>
<li>Third dim: The gids. </li>
</ul>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#a339e5109da9de77cbfde2a78787ad8bf">send_remote()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c81be0e25d1119664b4c7c35afa49e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long nest::Scheduler::t_real_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumunated wall-clock time spent simulating (in us) </p>

</div>
</div>
<a class="anchor" id="a591d802504ba8195c4f33fece633c683"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">timeval nest::Scheduler::t_slice_begin_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wall-clock time at the begin of a time slice. </p>

</div>
</div>
<a class="anchor" id="a409db592d512b03564155c8244ca18aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">timeval nest::Scheduler::t_slice_end_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wall-clock time at the end of time slice. </p>

</div>
</div>
<a class="anchor" id="a2532a56cee80e3532d9263cb8062b0d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nest::Scheduler::terminate_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminate on signal or error. </p>

<p>Referenced by <a class="el" href="classnest_1_1Scheduler.html#ac61af144516a230948e193bd492b56e8">terminate()</a>.</p>

</div>
</div>
<a class="anchor" id="ad158986b0786da045676391c73e7f7d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> nest::Scheduler::to_do_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of pending cycles. </p>

</div>
</div>
<a class="anchor" id="ab62b93dabc57d753c774d8bc87cc2315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> nest::Scheduler::to_do_total_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of requested cycles in current simulation. </p>

</div>
</div>
<a class="anchor" id="a93c8d251fbd9a3b99c638f2bc5a52042"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenest.html#a563db085e1869c0f9fd43c4ba282e176">delay</a> nest::Scheduler::to_step_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update clock_+from_step&lt;=T&lt;clock_+to_step_ </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="scheduler_8h_source.html">scheduler.h</a></li>
<li><a class="el" href="scheduler_8cpp.html">scheduler.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 26 2015 08:02:33 for NEST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
