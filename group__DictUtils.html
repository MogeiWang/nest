<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>NEST: How to access the value contained in a Token contained in a dictionary.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NEST
   &#160;<span id="projectnumber">2.6.0,not_revisioned_source_dir@0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">How to access the value contained in a Token contained in a dictionary.<div class="ingroups"><a class="el" href="group__TokenHandling.html">Handling classes Token and Dictionary.</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class <a class="el" href="classDictionary.html" title="A class that associates names and tokens. ">Dictionary</a> defines the standard user interface for accessing tokens from dictionaries (see there).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0445ccdaa7ff4b5a81644646bb83d631"><td class="memTemplParams" colspan="2">template&lt;typename FT &gt; </td></tr>
<tr class="memitem:ga0445ccdaa7ff4b5a81644646bb83d631"><td class="memTemplItemLeft" align="right" valign="top">FT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#ga0445ccdaa7ff4b5a81644646bb83d631">getValue</a> (const <a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;d, <a class="el" href="className.html">Name</a> const n)</td></tr>
<tr class="memdesc:ga0445ccdaa7ff4b5a81644646bb83d631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an existing dictionary entry.  <a href="#ga0445ccdaa7ff4b5a81644646bb83d631">More...</a><br /></td></tr>
<tr class="separator:ga0445ccdaa7ff4b5a81644646bb83d631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46187a005b28a029032ae44cdfacd12f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#ga46187a005b28a029032ae44cdfacd12f">get_double_in_range</a> (const <a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;d, <a class="el" href="className.html">Name</a> const n, double min, double max, int mode=2)</td></tr>
<tr class="memdesc:ga46187a005b28a029032ae44cdfacd12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an existing dictionary entry and check that it is in a specified range.  <a href="#ga46187a005b28a029032ae44cdfacd12f">More...</a><br /></td></tr>
<tr class="separator:ga46187a005b28a029032ae44cdfacd12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2884b30013642c7ea26a1a6e64707f8c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#ga2884b30013642c7ea26a1a6e64707f8c">get_long_in_range</a> (const <a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;d, <a class="el" href="className.html">Name</a> const n, long min, long max, int mode=2)</td></tr>
<tr class="memdesc:ga2884b30013642c7ea26a1a6e64707f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an existing dictionary entry and check that it is in a specified range.  <a href="#ga2884b30013642c7ea26a1a6e64707f8c">More...</a><br /></td></tr>
<tr class="separator:ga2884b30013642c7ea26a1a6e64707f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf5b108954ce819f3201465dfc2daa49"><td class="memTemplParams" colspan="2">template&lt;typename FT , class D &gt; </td></tr>
<tr class="memitem:gadf5b108954ce819f3201465dfc2daa49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#gadf5b108954ce819f3201465dfc2daa49">def2</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;d, <a class="el" href="className.html">Name</a> const n, FT const &amp;value)</td></tr>
<tr class="memdesc:gadf5b108954ce819f3201465dfc2daa49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a new dictionary entry from a fundamental type.  <a href="#gadf5b108954ce819f3201465dfc2daa49">More...</a><br /></td></tr>
<tr class="separator:gadf5b108954ce819f3201465dfc2daa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fcda26ba5ae984d7e6aa0e5bbfe4b72"><td class="memTemplParams" colspan="2">template&lt;typename FT &gt; </td></tr>
<tr class="memitem:ga6fcda26ba5ae984d7e6aa0e5bbfe4b72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#ga6fcda26ba5ae984d7e6aa0e5bbfe4b72">def</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;d, <a class="el" href="className.html">Name</a> const n, FT const &amp;value)</td></tr>
<tr class="memdesc:ga6fcda26ba5ae984d7e6aa0e5bbfe4b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a new dictionary entry from a fundamental type.  <a href="#ga6fcda26ba5ae984d7e6aa0e5bbfe4b72">More...</a><br /></td></tr>
<tr class="separator:ga6fcda26ba5ae984d7e6aa0e5bbfe4b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44cdfb140502a5d84d5a798c259f0073"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename VT &gt; </td></tr>
<tr class="memitem:ga44cdfb140502a5d84d5a798c259f0073"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#ga44cdfb140502a5d84d5a798c259f0073">updateValue</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> const &amp;d, <a class="el" href="className.html">Name</a> const n, VT &amp;value)</td></tr>
<tr class="memdesc:ga44cdfb140502a5d84d5a798c259f0073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a variable from a dictionary entry if it exists, skip call if it doesn't.  <a href="#ga44cdfb140502a5d84d5a798c259f0073">More...</a><br /></td></tr>
<tr class="separator:ga44cdfb140502a5d84d5a798c259f0073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5faad6767e320399223367fa2c04a8a7"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename VT , class C &gt; </td></tr>
<tr class="memitem:ga5faad6767e320399223367fa2c04a8a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#ga5faad6767e320399223367fa2c04a8a7">updateValue2</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> const &amp;d, <a class="el" href="className.html">Name</a> const n, C &amp;obj, void(C::*setfunc)(VT))</td></tr>
<tr class="memdesc:ga5faad6767e320399223367fa2c04a8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a member function of an object, passing the value of an dictionary entry if it exists, skip call if it doesn't.  <a href="#ga5faad6767e320399223367fa2c04a8a7">More...</a><br /></td></tr>
<tr class="separator:ga5faad6767e320399223367fa2c04a8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb39309693e8740af1323d58dae4277f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#gaeb39309693e8740af1323d58dae4277f">initialize_property_array</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;d, <a class="el" href="className.html">Name</a> propname)</td></tr>
<tr class="memdesc:gaeb39309693e8740af1323d58dae4277f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a property of type ArrayDatum in the dictionary, if it does not already exist.  <a href="#gaeb39309693e8740af1323d58dae4277f">More...</a><br /></td></tr>
<tr class="separator:gaeb39309693e8740af1323d58dae4277f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca5cefae6151612dea3da39adc295c78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#gaca5cefae6151612dea3da39adc295c78">initialize_property_doublevector</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;d, <a class="el" href="className.html">Name</a> propname)</td></tr>
<tr class="memdesc:gaca5cefae6151612dea3da39adc295c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a property of type DoubleVectorDatum in the dictionary, if it does not already exist.  <a href="#gaca5cefae6151612dea3da39adc295c78">More...</a><br /></td></tr>
<tr class="separator:gaca5cefae6151612dea3da39adc295c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc6126c32cd382bccbcfbc788c6f650f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#gadc6126c32cd382bccbcfbc788c6f650f">initialize_property_intvector</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;d, <a class="el" href="className.html">Name</a> propname)</td></tr>
<tr class="memdesc:gadc6126c32cd382bccbcfbc788c6f650f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a property of type IntVectorDatum in the dictionary, if it does not already exist.  <a href="#gadc6126c32cd382bccbcfbc788c6f650f">More...</a><br /></td></tr>
<tr class="separator:gadc6126c32cd382bccbcfbc788c6f650f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4634f6e310641d68ed5efe2a2181e96"><td class="memTemplParams" colspan="2">template&lt;typename PropT &gt; </td></tr>
<tr class="memitem:gad4634f6e310641d68ed5efe2a2181e96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#gad4634f6e310641d68ed5efe2a2181e96">append_property</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;d, <a class="el" href="className.html">Name</a> propname, const PropT &amp;prop)</td></tr>
<tr class="memdesc:gad4634f6e310641d68ed5efe2a2181e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a value to a property ArrayDatum in the dictionary.  <a href="#gad4634f6e310641d68ed5efe2a2181e96">More...</a><br /></td></tr>
<tr class="separator:gad4634f6e310641d68ed5efe2a2181e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3597227196f33fec1c8bb2f104ab2c57"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga3597227196f33fec1c8bb2f104ab2c57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#ga3597227196f33fec1c8bb2f104ab2c57">append_property&lt; std::vector&lt; double &gt; &gt;</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;d, <a class="el" href="className.html">Name</a> propname, const std::vector&lt; double &gt; &amp;prop)</td></tr>
<tr class="memdesc:ga3597227196f33fec1c8bb2f104ab2c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a value to a property DoubleVectorDatum in the dictionary.  <a href="#ga3597227196f33fec1c8bb2f104ab2c57">More...</a><br /></td></tr>
<tr class="separator:ga3597227196f33fec1c8bb2f104ab2c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf555c4346a3aeeae1e0b303beea2031"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:gabf555c4346a3aeeae1e0b303beea2031"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#gabf555c4346a3aeeae1e0b303beea2031">append_property&lt; std::vector&lt; long &gt; &gt;</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;d, <a class="el" href="className.html">Name</a> propname, const std::vector&lt; long &gt; &amp;prop)</td></tr>
<tr class="memdesc:gabf555c4346a3aeeae1e0b303beea2031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a value to a property IntVectorDatum in the dictionary.  <a href="#gabf555c4346a3aeeae1e0b303beea2031">More...</a><br /></td></tr>
<tr class="separator:gabf555c4346a3aeeae1e0b303beea2031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a520a9b1a45325ab4fcc550dee5e9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#gab7a520a9b1a45325ab4fcc550dee5e9b">provide_property</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;, <a class="el" href="className.html">Name</a>, const std::vector&lt; double &gt; &amp;)</td></tr>
<tr class="memdesc:gab7a520a9b1a45325ab4fcc550dee5e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a value to a property DoubleVectorDatum in the dictionary.  <a href="#gab7a520a9b1a45325ab4fcc550dee5e9b">More...</a><br /></td></tr>
<tr class="separator:gab7a520a9b1a45325ab4fcc550dee5e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82da5ec28b359fa7c8800c2c437a438a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#ga82da5ec28b359fa7c8800c2c437a438a">provide_property</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;, <a class="el" href="className.html">Name</a>, const std::vector&lt; long &gt; &amp;)</td></tr>
<tr class="memdesc:ga82da5ec28b359fa7c8800c2c437a438a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a value to a property IntVectorDatum in the dictionary.  <a href="#ga82da5ec28b359fa7c8800c2c437a438a">More...</a><br /></td></tr>
<tr class="separator:ga82da5ec28b359fa7c8800c2c437a438a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a7e892e132a5b1793361f38f5c3fbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DictUtils.html#gac6a7e892e132a5b1793361f38f5c3fbe">accumulate_property</a> (<a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;, <a class="el" href="className.html">Name</a>, const std::vector&lt; double &gt; &amp;)</td></tr>
<tr class="memdesc:gac6a7e892e132a5b1793361f38f5c3fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add values of a vector&lt;double&gt; to a property DoubleVectorDatum in the dictionary.  <a href="#gac6a7e892e132a5b1793361f38f5c3fbe">More...</a><br /></td></tr>
<tr class="separator:gac6a7e892e132a5b1793361f38f5c3fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Class <a class="el" href="classDictionary.html" title="A class that associates names and tokens. ">Dictionary</a> defines the standard user interface for accessing tokens from dictionaries (see there). </p>
<p>However, this user interface returns tokens, from which the actual value would still need to be extracted. The utilitiy functions described in this group shortcut this step and provide direct access to the underlying fundamental values associated to a dictionary entry. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac6a7e892e132a5b1793361f38f5c3fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void accumulate_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add values of a vector&lt;double&gt; to a property DoubleVectorDatum in the dictionary. </p>
<p>This variant of append_property is for adding vector&lt;double&gt;s to vector&lt;double&gt;s of the same size. It is required for collecting data across threads when multimeter is running in accumulation mode. </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, and <a class="el" href="classToken.html#a56ed9211562891a2cfa0c778719547e9">Token::datum()</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Multimeter.html#acc21c574f2a9ef442637baa8a817fafc">nest::Multimeter::add_data_()</a>.</p>

</div>
</div>
<a class="anchor" id="gad4634f6e310641d68ed5efe2a2181e96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void append_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a>&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PropT &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a value to a property ArrayDatum in the dictionary. </p>
<p>This is the version for scalar values </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, <a class="el" href="classToken.html#a56ed9211562891a2cfa0c778719547e9">Token::datum()</a>, and <a class="el" href="classToken.html#ac16a289fc0210b16c7aeaba30fbcbf50">Token::empty()</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Multimeter.html#acc21c574f2a9ef442637baa8a817fafc">nest::Multimeter::add_data_()</a>, <a class="el" href="structnest_1_1RecordingDevice_1_1Parameters__.html#aae36dcbd4ef56748142e581a37aacf67">nest::RecordingDevice::Parameters_::get()</a>, and <a class="el" href="structnest_1_1RecordingDevice_1_1State__.html#aeb3f21092afe9fc6c3083d4d0ce48408">nest::RecordingDevice::State_::get()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3597227196f33fec1c8bb2f104ab2c57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__DictUtils.html#gad4634f6e310641d68ed5efe2a2181e96">append_property</a>&lt; std::vector&lt; double &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a>&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a value to a property DoubleVectorDatum in the dictionary. </p>
<p>This is a specialization for appending vector&lt;double&gt;s to vector&lt;double&gt;s </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, <a class="el" href="classToken.html#a56ed9211562891a2cfa0c778719547e9">Token::datum()</a>, and <a class="el" href="classToken.html#ac16a289fc0210b16c7aeaba30fbcbf50">Token::empty()</a>.</p>

</div>
</div>
<a class="anchor" id="gabf555c4346a3aeeae1e0b303beea2031"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__DictUtils.html#gad4634f6e310641d68ed5efe2a2181e96">append_property</a>&lt; std::vector&lt; long &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a>&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a value to a property IntVectorDatum in the dictionary. </p>
<p>This is a specialization for appending vector&lt;long&gt;s to vector&lt;long&gt;s </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, <a class="el" href="classToken.html#a56ed9211562891a2cfa0c778719547e9">Token::datum()</a>, and <a class="el" href="classToken.html#ac16a289fc0210b16c7aeaba30fbcbf50">Token::empty()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6fcda26ba5ae984d7e6aa0e5bbfe4b72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void def </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a> const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FT const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a new dictionary entry from a fundamental type. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classTypeMismatch.html" title="Exception to be thrown if a given SLI type does not match the expected type. ">TypeMismatch</a></td><td>Creating a <a class="el" href="classToken.html" title="A type-independent container for C++-types. ">Token</a> from the fundamental type failed, probably due to a missing template specialization. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classnest_1_1Layer.html#af11bf4c93a71907d44fe2b2f9be5927a">nest::Layer&lt; D &gt;::dump_connections()</a>.</p>

</div>
</div>
<a class="anchor" id="gadf5b108954ce819f3201465dfc2daa49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void def2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a> const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FT const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a new dictionary entry from a fundamental type. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classTypeMismatch.html" title="Exception to be thrown if a given SLI type does not match the expected type. ">TypeMismatch</a></td><td>Fundamental type and requested SLI type are incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga46187a005b28a029032ae44cdfacd12f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double get_double_in_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a> const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of an existing dictionary entry and check that it is in a specified range. </p>
<p>The range is specified by two parameters min and max which have the same type as the template argument. The last parameter mode defines the type of the range: </p><h2>Mode Relation </h2>
<p>0 min &lt; x &lt; max 1 min &lt;= x &lt; max 2 min &lt;= x &lt;= max</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnknownName</td><td>An entry of the given name is not known in the dictionary. </td></tr>
    <tr><td class="paramname"><a class="el" href="classRangeCheck.html" title="Exception to be thrown if a given SLI array has the wrong size. ">RangeCheck</a></td><td>if a value is outside the range </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classToken.html#a56ed9211562891a2cfa0c778719547e9">Token::datum()</a>, <a class="el" href="classGenericDatum.html#acfcadc607f7d45837e8004c92629d1b7">GenericDatum&lt; D, slt &gt;::get()</a>, and <a class="el" href="namespacenest_1_1names.html#a351824b0b77219f5761c0bfa05d7c523">nest::names::x</a>.</p>

</div>
</div>
<a class="anchor" id="ga2884b30013642c7ea26a1a6e64707f8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long get_long_in_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a> const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of an existing dictionary entry and check that it is in a specified range. </p>
<p>The range is specified by two parameters min and max which have the same type as the template argument. The last parameter mode defines the type of the range: </p><h2>Mode Relation </h2>
<p>0 min &lt; x &lt; max 1 min &lt;= x &lt; max 2 min &lt;= x &lt;= max</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnknownName</td><td>An entry of the given name is not known in the dictionary. </td></tr>
    <tr><td class="paramname"><a class="el" href="classRangeCheck.html" title="Exception to be thrown if a given SLI array has the wrong size. ">RangeCheck</a></td><td>if a value is outside the range </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classToken.html#a56ed9211562891a2cfa0c778719547e9">Token::datum()</a>, <a class="el" href="classGenericDatum.html#acfcadc607f7d45837e8004c92629d1b7">GenericDatum&lt; D, slt &gt;::get()</a>, and <a class="el" href="namespacenest_1_1names.html#a351824b0b77219f5761c0bfa05d7c523">nest::names::x</a>.</p>

</div>
</div>
<a class="anchor" id="ga0445ccdaa7ff4b5a81644646bb83d631"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FT getValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a> const&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of an existing dictionary entry. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnknownName</td><td>An entry of the given name is not known in the dictionary. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="namespacenest.html#a016f9f27d85289b26feb1aa2987f9f60">nest::create_doughnut()</a>, <a class="el" href="classSLIArrayModule_1_1Array2IntVectorFunction.html#a7e61b0fdc243e94b72d1d8b46ddbb592">SLIArrayModule::Array2IntVectorFunction::execute()</a>, and <a class="el" href="classSLIArrayModule_1_1Array2DoubleVectorFunction.html#a716b28c3bc945764021576cc9777413a">SLIArrayModule::Array2DoubleVectorFunction::execute()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb39309693e8740af1323d58dae4277f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_property_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a>&#160;</td>
          <td class="paramname"><em>propname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a property of type ArrayDatum in the dictionary, if it does not already exist. </p>

<p>References <a class="el" href="namespacenest_1_1names.html#ab8c67898fb04b2e13acb81c4d2b5bcdb">nest::names::d</a>, and <a class="el" href="classToken.html#ac16a289fc0210b16c7aeaba30fbcbf50">Token::empty()</a>.</p>

<p>Referenced by <a class="el" href="structnest_1_1RecordingDevice_1_1Parameters__.html#aae36dcbd4ef56748142e581a37aacf67">nest::RecordingDevice::Parameters_::get()</a>.</p>

</div>
</div>
<a class="anchor" id="gaca5cefae6151612dea3da39adc295c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_property_doublevector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a>&#160;</td>
          <td class="paramname"><em>propname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a property of type DoubleVectorDatum in the dictionary, if it does not already exist. </p>

<p>References <a class="el" href="namespacenest_1_1names.html#ab8c67898fb04b2e13acb81c4d2b5bcdb">nest::names::d</a>, and <a class="el" href="classToken.html#ac16a289fc0210b16c7aeaba30fbcbf50">Token::empty()</a>.</p>

<p>Referenced by <a class="el" href="classnest_1_1Multimeter.html#acc21c574f2a9ef442637baa8a817fafc">nest::Multimeter::add_data_()</a>, and <a class="el" href="structnest_1_1RecordingDevice_1_1State__.html#aeb3f21092afe9fc6c3083d4d0ce48408">nest::RecordingDevice::State_::get()</a>.</p>

</div>
</div>
<a class="anchor" id="gadc6126c32cd382bccbcfbc788c6f650f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_property_intvector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a>&#160;</td>
          <td class="paramname"><em>propname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a property of type IntVectorDatum in the dictionary, if it does not already exist. </p>

<p>References <a class="el" href="namespacenest_1_1names.html#ab8c67898fb04b2e13acb81c4d2b5bcdb">nest::names::d</a>, and <a class="el" href="classToken.html#ac16a289fc0210b16c7aeaba30fbcbf50">Token::empty()</a>.</p>

<p>Referenced by <a class="el" href="structnest_1_1RecordingDevice_1_1State__.html#aeb3f21092afe9fc6c3083d4d0ce48408">nest::RecordingDevice::State_::get()</a>.</p>

</div>
</div>
<a class="anchor" id="gab7a520a9b1a45325ab4fcc550dee5e9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void provide_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a value to a property DoubleVectorDatum in the dictionary. </p>
<p>In contrast to append_property, this function adds the value only once to the property. On all subsequent events, it ensures that the value passed in is identical to the value present. This is needed by recording_decive. </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, and <a class="el" href="classToken.html#a56ed9211562891a2cfa0c778719547e9">Token::datum()</a>.</p>

<p>Referenced by <a class="el" href="structnest_1_1RecordingDevice_1_1State__.html#aeb3f21092afe9fc6c3083d4d0ce48408">nest::RecordingDevice::State_::get()</a>.</p>

</div>
</div>
<a class="anchor" id="ga82da5ec28b359fa7c8800c2c437a438a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void provide_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a value to a property IntVectorDatum in the dictionary. </p>
<p>In contrast to append_property, this function adds the value only once to the property. On all subsequent events, it ensures that the value passed in is identical to the value present. This is needed by recording_decive. </p>

<p>References <a class="el" href="neststartup_8cpp.html#ae30233134dff5ec4ec526077406f36d1">assert()</a>, and <a class="el" href="classToken.html#a56ed9211562891a2cfa0c778719547e9">Token::datum()</a>.</p>

</div>
</div>
<a class="anchor" id="ga44cdfb140502a5d84d5a798c259f0073"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool updateValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> const &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a> const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a variable from a dictionary entry if it exists, skip call if it doesn't. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">see</td><td>getValue(DictionaryDatum, Name) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classToken.html#ac16a289fc0210b16c7aeaba30fbcbf50">Token::empty()</a>.</p>

<p>Referenced by <a class="el" href="structnest_1_1pulsepacket__generator_1_1Parameters__.html#a3d50e0cdf30807c5e37314f7ed5462a5">nest::pulsepacket_generator::Parameters_::set()</a>, <a class="el" href="structnest_1_1iaf__psc__exp__multisynapse_1_1Parameters__.html#a2f17cf95568bde0ed0f3abfb0fc6232f">nest::iaf_psc_exp_multisynapse::Parameters_::set()</a>, <a class="el" href="structnest_1_1iaf__psc__alpha__multisynapse_1_1Parameters__.html#a3de5e882f1e4951fce6a363102e76493">nest::iaf_psc_alpha_multisynapse::Parameters_::set()</a>, <a class="el" href="structnest_1_1aeif__cond__alpha__multisynapse_1_1Parameters__.html#a20ba7b96a0a6f8fcf62a9e9649126121">nest::aeif_cond_alpha_multisynapse::Parameters_::set()</a>, and <a class="el" href="structnest_1_1correlation__detector_1_1State__.html#ab9d33b26d290b3b1ae724d1678255089">nest::correlation_detector::State_::set()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5faad6767e320399223367fa2c04a8a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename VT , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void updateValue2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dictdatum_8h.html#a97dce7cd2e0367fc559e8ce381d1c64b">DictionaryDatum</a> const &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="className.html">Name</a> const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(C::*)(VT)&#160;</td>
          <td class="paramname"><em>setfunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a member function of an object, passing the value of an dictionary entry if it exists, skip call if it doesn't. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">see</td><td>getValue(DictionaryDatum, Name) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 26 2015 08:02:28 for NEST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
